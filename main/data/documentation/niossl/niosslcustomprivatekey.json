{"abstract":[{"type":"reference","isActive":true,"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLCustomPrivateKey"},{"text":" defines the interface of a custom, non-BoringSSL private key.","type":"text"}],"topicSections":[{"title":"Instance Properties","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLCustomPrivateKey\/signatureAlgorithms"]},{"title":"Instance Methods","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLCustomPrivateKey\/decrypt(channel:data:)","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLCustomPrivateKey\/sign(channel:algorithm:data:)"]}],"sections":[],"identifier":{"url":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLCustomPrivateKey","interfaceLanguage":"swift"},"schemaVersion":{"patch":0,"minor":3,"major":0},"hierarchy":{"paths":[["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL"]]},"relationshipsSections":[{"title":"Inherits From","type":"inheritsFrom","kind":"relationships","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOPreconcurrencySendable"]}],"primaryContentSections":[{"kind":"declarations","declarations":[{"languages":["swift"],"tokens":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOSSLCustomPrivateKey","kind":"identifier"},{"text":" : ","kind":"text"},{"text":"NIOPreconcurrencySendable","preciseIdentifier":"s:7NIOCore25NIOPreconcurrencySendableP","kind":"typeIdentifier","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOPreconcurrencySendable"}],"platforms":["Linux"]}]},{"kind":"content","content":[{"type":"heading","level":2,"anchor":"overview","text":"Overview"},{"type":"paragraph","inlineContent":[{"text":"In a number of circumstances it is advantageous to store a TLS private key in some form of high-security storage,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"such as a smart card. In these cases it is not possible to represent the TLS private key directly as a sequence"},{"type":"text","text":" "},{"type":"text","text":"of bytes that BoringSSL will understand."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This protocol allows a type to implement callbacks that perform the specific operation required by the TLS handshake."},{"type":"text","text":" "},{"type":"text","text":"Implementers are required to specify what signature algorithms they support, and then must implement "},{"type":"strong","inlineContent":[{"type":"text","text":"only one"}]},{"type":"text","text":" of"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"reference","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLCustomPrivateKey\/sign(channel:algorithm:data:)","isActive":true},{"type":"text","text":" and "},{"type":"reference","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLCustomPrivateKey\/decrypt(channel:data:)","isActive":true},{"type":"text","text":" "},{"type":"text","text":"functions. For elliptic curve keys, implementers should implement "},{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLCustomPrivateKey\/sign(channel:algorithm:data:)","isActive":true,"type":"reference"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"For RSA keys, implementers should implement "},{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLCustomPrivateKey\/sign(channel:algorithm:data:)","isActive":true,"type":"reference"},{"type":"text","text":" and, if supporting"},{"type":"text","text":" "},{"type":"text","text":"RSA key exchange in TLS versions before 1.3, you should also implement "},{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLCustomPrivateKey\/decrypt(channel:data:)","isActive":true,"type":"reference"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"If the same ","type":"text"},{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLCustomPrivateKey","isActive":true,"type":"reference"},{"text":" implementation is used by multiple channels at once, then no synchronization","type":"text"},{"text":" ","type":"text"},{"text":"is imposed by SwiftNIO. The calls to the protocol requirements will be made on event loop threads, so if further","type":"text"},{"text":" ","type":"text"},{"text":"synchronization is required it is up to the implementer to provide it. Note that it is unacceptable to block in","type":"text"},{"text":" ","type":"text"},{"text":"these functions, and so potentially blocking operations must delegate to another thread.","type":"text"}]}]}],"kind":"symbol","variants":[{"paths":["\/documentation\/niossl\/niosslcustomprivatekey"],"traits":[{"interfaceLanguage":"swift"}]}],"metadata":{"externalID":"s:6NIOSSL22NIOSSLCustomPrivateKeyP","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOSSLCustomPrivateKey"}],"roleHeading":"Protocol","symbolKind":"protocol","role":"symbol","modules":[{"name":"NIOSSL"}],"navigatorTitle":[{"kind":"identifier","text":"NIOSSLCustomPrivateKey"}],"title":"NIOSSLCustomPrivateKey"},"references":{"doc://co.pointfree.VaporRouting/documentation/NIOSSL/NIOSSLCustomPrivateKey/signatureAlgorithms":{"abstract":[{"text":"The signature algorithms supported by this key.","type":"text"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLCustomPrivateKey\/signatureAlgorithms","role":"symbol","url":"\/documentation\/niossl\/niosslcustomprivatekey\/signaturealgorithms","title":"signatureAlgorithms","type":"topic","kind":"symbol","required":true,"fragments":[{"text":"var","kind":"keyword"},{"text":" ","kind":"text"},{"text":"signatureAlgorithms","kind":"identifier"},{"text":": [","kind":"text"},{"text":"SignatureAlgorithm","preciseIdentifier":"s:6NIOSSL18SignatureAlgorithmV","kind":"typeIdentifier"},{"text":"]","kind":"text"}]},"doc://co.pointfree.VaporRouting/documentation/NIOSSL/NIOSSLCustomPrivateKey":{"type":"topic","url":"\/documentation\/niossl\/niosslcustomprivatekey","navigatorTitle":[{"text":"NIOSSLCustomPrivateKey","kind":"identifier"}],"title":"NIOSSLCustomPrivateKey","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLCustomPrivateKey","abstract":[{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLCustomPrivateKey","isActive":true,"type":"reference"},{"text":" defines the interface of a custom, non-BoringSSL private key.","type":"text"}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOSSLCustomPrivateKey","kind":"identifier"}],"kind":"symbol","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOSSL/NIOSSLCustomPrivateKey/sign(channel:algorithm:data:)":{"type":"topic","url":"\/documentation\/niossl\/niosslcustomprivatekey\/sign(channel:algorithm:data:)","title":"sign(channel:algorithm:data:)","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLCustomPrivateKey\/sign(channel:algorithm:data:)","abstract":[{"text":"Called to perform a signing operation.","type":"text"}],"fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"sign","kind":"identifier"},{"text":"(","kind":"text"},{"text":"channel","kind":"externalParam"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:7NIOCore7ChannelP","text":"Channel","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"algorithm","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"SignatureAlgorithm","preciseIdentifier":"s:6NIOSSL18SignatureAlgorithmV","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"data","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"ByteBuffer","preciseIdentifier":"s:7NIOCore10ByteBufferV","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"text":"EventLoopFuture","preciseIdentifier":"s:7NIOCore15EventLoopFutureC","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"text":"ByteBuffer","preciseIdentifier":"s:7NIOCore10ByteBufferV","kind":"typeIdentifier"},{"text":">","kind":"text"}],"kind":"symbol","role":"symbol","required":true},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOPreconcurrencySendable":{"title":"NIOPreconcurrencySendable","type":"topic","role":"symbol","url":"\/documentation\/niocore\/niopreconcurrencysendable","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOPreconcurrencySendable"}],"navigatorTitle":[{"kind":"identifier","text":"NIOPreconcurrencySendable"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOPreconcurrencySendable","kind":"symbol","abstract":[]},"doc://co.pointfree.VaporRouting/documentation/NIOSSL":{"url":"\/documentation\/niossl","kind":"symbol","type":"topic","abstract":[],"role":"collection","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL","title":"NIOSSL"},"doc://co.pointfree.VaporRouting/documentation/NIOSSL/NIOSSLCustomPrivateKey/decrypt(channel:data:)":{"url":"\/documentation\/niossl\/niosslcustomprivatekey\/decrypt(channel:data:)","type":"topic","role":"symbol","kind":"symbol","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"decrypt"},{"kind":"text","text":"("},{"kind":"externalParam","text":"channel"},{"kind":"text","text":": "},{"preciseIdentifier":"s:7NIOCore7ChannelP","kind":"typeIdentifier","text":"Channel"},{"text":", ","kind":"text"},{"text":"data","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"ByteBuffer","preciseIdentifier":"s:7NIOCore10ByteBufferV","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"text":"EventLoopFuture","preciseIdentifier":"s:7NIOCore15EventLoopFutureC","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"text":"ByteBuffer","preciseIdentifier":"s:7NIOCore10ByteBufferV","kind":"typeIdentifier"},{"text":">","kind":"text"}],"abstract":[{"type":"text","text":"Called to perform a decryption operation."}],"required":true,"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLCustomPrivateKey\/decrypt(channel:data:)","title":"decrypt(channel:data:)"}}}