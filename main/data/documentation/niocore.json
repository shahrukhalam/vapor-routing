{"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore"},"hierarchy":{"paths":[[]]},"schemaVersion":{"minor":3,"major":0,"patch":0},"kind":"symbol","metadata":{"roleHeading":"Framework","title":"NIOCore","symbolKind":"module","role":"collection","modules":[{"name":"NIOCore"}],"externalID":"NIOCore"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/niocore"]}],"topicSections":[{"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/AcceptBackoffHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/BackPressureHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelHandlerContext","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelPipeline","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/EventLoopFuture","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/IdleStateHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/MessageToByteHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOCloseOnErrorHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOFileHandle","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIONetworkInterface","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOSingleStepByteToMessageProcessor","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RepeatedTask"],"title":"Classes"},{"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/Channel","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelCore","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelInboundHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelInboundInvoker","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelInvoker","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOutboundHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOutboundInvoker","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/EventLoop","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/EventLoopGroup","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/FileDescriptor","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/MessageToByteEncoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/MulticastChannel","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOClientTCPBootstrapProtocol","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOClientTLSProvider","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOPreconcurrencySendable","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOSingleStepByteToMessageDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOSynchronousChannelOptions","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RecvByteBufferAllocator","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RemovableChannelHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/SocketOptionProvider","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/WriteObservingByteToMessageDecoder"],"title":"Protocols"},{"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/AdaptiveRecvByteBufferAllocator","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/AddressedEnvelope","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteBuffer","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteBufferAllocator","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteBufferView","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelShouldQuiesceEvent","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/CircularBuffer","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/EventLoopIterator","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/EventLoopPromise","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/FileRegion","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/FixedSizeRecvByteBufferAllocator","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/IOError","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/MarkedCircularBuffer","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOAny","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOAttemptedToRemoveHandlerMultipleTimesError","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOClientTCPBootstrap","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIODeadline","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOInsecureNoTLS","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOMulticastNotImplementedError","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOMulticastNotSupportedError","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIONetworkDevice","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOPacketInfo","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/Scheduled","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/TimeAmount"],"title":"Structures"},{"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/AllocatorOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/AllowRemoteHalfClosureOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/AutoReadOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/BacklogOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelDuplexHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ConnectTimeoutOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/DatagramVectorReadMessageCountOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/MaxMessagesPerReadOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOPOSIXFileMode","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOSendable","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RecvAllocatorOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/SocketOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/SocketOptionLevel","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/SocketOptionName","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/SocketOptionValue","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/WriteBufferWaterMark","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/WriteBufferWaterMarkOption","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/WriteSpinOption"],"title":"Type Aliases"},{"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoderError","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelError","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelEvent","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelPipelineError","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/CloseMode","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/DatagramChannelError","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/DecodingState","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/Endianness","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/EventLoopError","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/IOData","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOBSDSocket","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOEventLoopGroupProvider","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOExplicitCongestionNotificationState","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/SocketAddress","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/SocketAddressError","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/System"],"title":"Enumerations"}],"sections":[],"references":{"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOPreconcurrencySendable":{"title":"NIOPreconcurrencySendable","type":"topic","role":"symbol","url":"\/documentation\/niocore\/niopreconcurrencysendable","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOPreconcurrencySendable"}],"navigatorTitle":[{"kind":"identifier","text":"NIOPreconcurrencySendable"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOPreconcurrencySendable","kind":"symbol","abstract":[]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/EventLoop":{"abstract":[{"type":"text","text":"An EventLoop processes IO \/ tasks in an endless loop for "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":"s until it’s closed."}],"url":"\/documentation\/niocore\/eventloop","type":"topic","title":"EventLoop","role":"symbol","navigatorTitle":[{"text":"EventLoop","kind":"identifier"}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"EventLoop","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/EventLoop","kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOClientTLSProvider":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOClientTLSProvider","title":"NIOClientTLSProvider","abstract":[],"role":"symbol","type":"topic","kind":"symbol","url":"\/documentation\/niocore\/nioclienttlsprovider","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOClientTLSProvider","kind":"identifier"}],"navigatorTitle":[{"text":"NIOClientTLSProvider","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/FileRegion":{"navigatorTitle":[{"text":"FileRegion","kind":"identifier"}],"type":"topic","kind":"symbol","abstract":[{"text":"A ","type":"text"},{"code":"FileRegion","type":"codeVoice"},{"text":" represent a readable portion usually created to be sent over the network.","type":"text"}],"url":"\/documentation\/niocore\/fileregion","title":"FileRegion","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"FileRegion","kind":"identifier"}],"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/FileRegion"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/CircularBuffer":{"role":"symbol","kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/CircularBuffer","title":"CircularBuffer","type":"topic","url":"\/documentation\/niocore\/circularbuffer","abstract":[{"type":"text","text":"An automatically expanding ring buffer implementation backed by a "},{"type":"codeVoice","code":"ContiguousArray"},{"type":"text","text":". Even though this implementation"},{"type":"text","text":" "},{"type":"text","text":"will automatically expand if more elements than "},{"type":"codeVoice","code":"initialCapacity"},{"text":" are stored, it’s advantageous to prevent","type":"text"},{"text":" ","type":"text"},{"text":"expansions from happening frequently. Expansions will always force an allocation and a copy to happen.","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"CircularBuffer"}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"CircularBuffer"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOFileHandle":{"title":"NIOFileHandle","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOFileHandle","url":"\/documentation\/niocore\/niofilehandle","abstract":[{"text":"A ","type":"text"},{"type":"codeVoice","code":"NIOFileHandle"},{"text":" is a handle to an open file.","type":"text"}],"role":"symbol","type":"topic","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOFileHandle"}],"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"NIOFileHandle"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIODeadline":{"url":"\/documentation\/niocore\/niodeadline","type":"topic","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIODeadline"}],"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"NIODeadline"}],"title":"NIODeadline","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIODeadline","abstract":[{"text":"Represents a point in time.","type":"text"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/FileDescriptor":{"fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"FileDescriptor"}],"url":"\/documentation\/niocore\/filedescriptor","kind":"symbol","title":"FileDescriptor","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/FileDescriptor","role":"symbol","abstract":[],"navigatorTitle":[{"kind":"identifier","text":"FileDescriptor"}],"type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelCore":{"type":"topic","kind":"symbol","role":"symbol","title":"ChannelCore","url":"\/documentation\/niocore\/channelcore","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ChannelCore"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelCore","abstract":[{"type":"text","text":"The core "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" methods that are for internal use of the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" implementation only."}],"navigatorTitle":[{"kind":"identifier","text":"ChannelCore"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore":{"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore","kind":"symbol","title":"NIOCore","abstract":[],"url":"\/documentation\/niocore","role":"collection"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/SocketAddressError":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/SocketAddressError","fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"text":"SocketAddressError","kind":"identifier"}],"url":"\/documentation\/niocore\/socketaddresserror","abstract":[{"text":"Special ","type":"text"},{"code":"Error","type":"codeVoice"},{"text":" that may be thrown if we fail to create a ","type":"text"},{"code":"SocketAddress","type":"codeVoice"},{"text":".","type":"text"}],"navigatorTitle":[{"text":"SocketAddressError","kind":"identifier"}],"kind":"symbol","type":"topic","role":"symbol","title":"SocketAddressError"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/MessageToByteHandler":{"abstract":[{"type":"text","text":"A handler which turns a given "},{"code":"MessageToByteEncoder","type":"codeVoice"},{"type":"text","text":" into a "},{"code":"ChannelOutboundHandler","type":"codeVoice"},{"type":"text","text":" that can then be added to a"},{"type":"text","text":" "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":"."}],"navigatorTitle":[{"text":"MessageToByteHandler","kind":"identifier"}],"url":"\/documentation\/niocore\/messagetobytehandler","role":"symbol","kind":"symbol","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"MessageToByteHandler","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/MessageToByteHandler","type":"topic","title":"MessageToByteHandler"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOPacketInfo":{"kind":"symbol","navigatorTitle":[{"text":"NIOPacketInfo","kind":"identifier"}],"url":"\/documentation\/niocore\/niopacketinfo","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOPacketInfo","role":"symbol","title":"NIOPacketInfo","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOPacketInfo","kind":"identifier"}],"abstract":[]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/System":{"fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"text":"System","kind":"identifier"}],"kind":"symbol","type":"topic","abstract":[],"navigatorTitle":[{"text":"System","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/System","url":"\/documentation\/niocore\/system","title":"System","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/IOData":{"title":"IOData","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/IOData","kind":"symbol","role":"symbol","abstract":[{"code":"IOData","type":"codeVoice"},{"text":" unifies standard SwiftNIO types that are raw bytes of data; currently ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"FileRegion","type":"codeVoice"},{"text":".","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"IOData"}],"type":"topic","url":"\/documentation\/niocore\/iodata","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"IOData"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/SocketAddress":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/SocketAddress","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"SocketAddress"}],"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"SocketAddress"}],"url":"\/documentation\/niocore\/socketaddress","role":"symbol","type":"topic","abstract":[{"type":"text","text":"Represent a socket address to which we may want to connect or bind."}],"title":"SocketAddress"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/MessageToByteEncoder":{"url":"\/documentation\/niocore\/messagetobyteencoder","abstract":[{"text":"A protocol for straightforward encoders which encode custom messages to ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":"s.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"To add a "},{"code":"MessageToByteEncoder","type":"codeVoice"},{"type":"text","text":" to a "},{"code":"ChannelPipeline","type":"codeVoice"},{"text":", use","type":"text"},{"text":" ","type":"text"},{"code":"channel.pipeline.addHandler(MessageToByteHandler(myEncoder)","type":"codeVoice"},{"text":".","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"MessageToByteEncoder"}],"kind":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"MessageToByteEncoder"}],"title":"MessageToByteEncoder","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/MessageToByteEncoder","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOEventLoopGroupProvider":{"kind":"symbol","title":"NIOEventLoopGroupProvider","abstract":[{"text":"This type is intended to be used by libraries which use NIO, and offer their users either the option","type":"text"},{"text":" ","type":"text"},{"text":"to ","type":"text"},{"type":"codeVoice","code":".share"},{"text":" an existing event loop group or create (and manage) a new one (","type":"text"},{"type":"codeVoice","code":".createNew"},{"text":") and let it be","type":"text"},{"type":"text","text":" "},{"type":"text","text":"managed by given library and its lifecycle."}],"navigatorTitle":[{"kind":"identifier","text":"NIOEventLoopGroupProvider"}],"type":"topic","role":"symbol","url":"\/documentation\/niocore\/nioeventloopgroupprovider","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOEventLoopGroupProvider"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOEventLoopGroupProvider"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOBSDSocket":{"title":"NIOBSDSocket","role":"symbol","type":"topic","url":"\/documentation\/niocore\/niobsdsocket","abstract":[],"kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOBSDSocket","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOBSDSocket"}],"navigatorTitle":[{"kind":"identifier","text":"NIOBSDSocket"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/SocketOptionLevel":{"fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"SocketOptionLevel"}],"abstract":[],"kind":"symbol","url":"\/documentation\/niocore\/socketoptionlevel","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/SocketOptionLevel","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"SocketOptionLevel"}],"title":"SocketOptionLevel","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/DatagramVectorReadMessageCountOption":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/DatagramVectorReadMessageCountOption","abstract":[],"role":"symbol","title":"DatagramVectorReadMessageCountOption","kind":"symbol","fragments":[{"text":"typealias","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"DatagramVectorReadMessageCountOption"}],"type":"topic","url":"\/documentation\/niocore\/datagramvectorreadmessagecountoption","navigatorTitle":[{"kind":"identifier","text":"DatagramVectorReadMessageCountOption"}],"deprecated":true},"doc://co.pointfree.VaporRouting/documentation/NIOCore/EventLoopFuture":{"url":"\/documentation\/niocore\/eventloopfuture","kind":"symbol","type":"topic","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"EventLoopFuture"}],"navigatorTitle":[{"kind":"identifier","text":"EventLoopFuture"}],"abstract":[{"type":"text","text":"Holder for a result that will be provided later."}],"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/EventLoopFuture","title":"EventLoopFuture"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/TimeAmount":{"abstract":[{"text":"Represents a time ","type":"text"},{"inlineContent":[{"type":"text","text":"interval"}],"type":"emphasis"},{"text":".","type":"text"}],"type":"topic","navigatorTitle":[{"text":"TimeAmount","kind":"identifier"}],"kind":"symbol","title":"TimeAmount","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"text":"TimeAmount","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/TimeAmount","url":"\/documentation\/niocore\/timeamount","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/IOError":{"navigatorTitle":[{"text":"IOError","kind":"identifier"}],"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/IOError","kind":"symbol","role":"symbol","abstract":[{"text":"An ","type":"text"},{"code":"Error","type":"codeVoice"},{"text":" for an IO operation.","type":"text"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"IOError","kind":"identifier"}],"title":"IOError","url":"\/documentation\/niocore\/ioerror"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOClientTCPBootstrapProtocol":{"url":"\/documentation\/niocore\/nioclienttcpbootstrapprotocol","kind":"symbol","title":"NIOClientTCPBootstrapProtocol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOClientTCPBootstrapProtocol","type":"topic","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOClientTCPBootstrapProtocol"}],"role":"symbol","abstract":[{"code":"NIOClientTCPBootstrapProtocol","type":"codeVoice"},{"type":"text","text":" is implemented by various underlying transport mechanisms. Typically,"},{"type":"text","text":" "},{"type":"text","text":"this will be the BSD Sockets API implemented by "},{"code":"ClientBootstrap","type":"codeVoice"},{"type":"text","text":"."}],"navigatorTitle":[{"kind":"identifier","text":"NIOClientTCPBootstrapProtocol"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/AutoReadOption":{"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/AutoReadOption","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"text":"AutoReadOption","kind":"identifier"}],"kind":"symbol","navigatorTitle":[{"text":"AutoReadOption","kind":"identifier"}],"abstract":[],"type":"topic","title":"AutoReadOption","deprecated":true,"url":"\/documentation\/niocore\/autoreadoption"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/Channel":{"kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/Channel","type":"topic","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Channel"}],"navigatorTitle":[{"kind":"identifier","text":"Channel"}],"url":"\/documentation\/niocore\/channel","abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" is easiest thought of as a network socket. But it can be anything that is capable of I\/O operations such"},{"type":"text","text":" "},{"type":"text","text":"as read, write, connect, and bind."}],"title":"Channel","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelPipeline":{"url":"\/documentation\/niocore\/channelpipeline","kind":"symbol","abstract":[{"type":"text","text":"A list of "},{"type":"codeVoice","code":"ChannelHandler"},{"type":"text","text":"s that handle or intercept inbound events and outbound operations of a"},{"type":"text","text":" "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":". "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":" implements an advanced form of the Intercepting Filter pattern"},{"type":"text","text":" "},{"type":"text","text":"to give a user full control over how an event is handled and how the "},{"type":"codeVoice","code":"ChannelHandler"},{"type":"text","text":"s in a pipeline"},{"type":"text","text":" "},{"type":"text","text":"interact with each other."}],"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelPipeline","title":"ChannelPipeline","navigatorTitle":[{"text":"ChannelPipeline","kind":"identifier"}],"fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ChannelPipeline","kind":"identifier"}],"role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOCloseOnErrorHandler":{"type":"topic","abstract":[{"type":"text","text":"A "},{"code":"ChannelInboundHandler","type":"codeVoice"},{"type":"text","text":" that closes the channel when an error is caught"}],"kind":"symbol","url":"\/documentation\/niocore\/niocloseonerrorhandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOCloseOnErrorHandler","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOCloseOnErrorHandler","navigatorTitle":[{"text":"NIOCloseOnErrorHandler","kind":"identifier"}],"role":"symbol","title":"NIOCloseOnErrorHandler"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ConnectTimeoutOption":{"kind":"symbol","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ConnectTimeoutOption","type":"topic","navigatorTitle":[{"text":"ConnectTimeoutOption","kind":"identifier"}],"abstract":[],"fragments":[{"text":"typealias","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ConnectTimeoutOption","kind":"identifier"}],"url":"\/documentation\/niocore\/connecttimeoutoption","title":"ConnectTimeoutOption","deprecated":true},"doc://co.pointfree.VaporRouting/documentation/NIOCore/SocketOptionProvider":{"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"SocketOptionProvider"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/SocketOptionProvider","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"SocketOptionProvider"}],"type":"topic","role":"symbol","abstract":[{"type":"text","text":"This protocol defines an object, most commonly a "},{"code":"Channel","type":"codeVoice"},{"text":", that supports","type":"text"},{"text":" ","type":"text"},{"text":"setting and getting socket options (via ","type":"text"},{"code":"setsockopt","type":"codeVoice"},{"text":"\/","type":"text"},{"code":"getsockopt","type":"codeVoice"},{"text":" or similar).","type":"text"},{"text":" ","type":"text"},{"text":"It provides a strongly typed API that makes working with larger, less-common","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"socket options easier than the "},{"code":"ChannelOption","type":"codeVoice"},{"type":"text","text":" API allows."}],"url":"\/documentation\/niocore\/socketoptionprovider","title":"SocketOptionProvider"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOExplicitCongestionNotificationState":{"abstract":[{"text":"Possible Explicit Congestion Notification States","type":"text"}],"kind":"symbol","url":"\/documentation\/niocore\/nioexplicitcongestionnotificationstate","role":"symbol","fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOExplicitCongestionNotificationState","kind":"identifier"}],"type":"topic","navigatorTitle":[{"text":"NIOExplicitCongestionNotificationState","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOExplicitCongestionNotificationState","title":"NIOExplicitCongestionNotificationState"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/AddressedEnvelope":{"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"AddressedEnvelope"}],"url":"\/documentation\/niocore\/addressedenvelope","type":"topic","title":"AddressedEnvelope","abstract":[{"text":"A data structure for processing addressed datagrams, such as those used by UDP.","type":"text"}],"role":"symbol","navigatorTitle":[{"kind":"identifier","text":"AddressedEnvelope"}],"kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/AddressedEnvelope"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/CloseMode":{"navigatorTitle":[{"text":"CloseMode","kind":"identifier"}],"title":"CloseMode","url":"\/documentation\/niocore\/closemode","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/CloseMode","abstract":[{"text":"Specify what kind of close operation is requested.","type":"text"}],"role":"symbol","fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"text":"CloseMode","kind":"identifier"}],"kind":"symbol","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/AllocatorOption":{"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/AllocatorOption","url":"\/documentation\/niocore\/allocatoroption","navigatorTitle":[{"kind":"identifier","text":"AllocatorOption"}],"type":"topic","title":"AllocatorOption","abstract":[],"kind":"symbol","deprecated":true,"fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"AllocatorOption"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOAny":{"kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOAny","url":"\/documentation\/niocore\/nioany","type":"topic","title":"NIOAny","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOAny","kind":"identifier"}],"navigatorTitle":[{"text":"NIOAny","kind":"identifier"}],"abstract":[{"code":"NIOAny","type":"codeVoice"},{"text":" is an opaque container for values of ","type":"text"},{"inlineContent":[{"text":"any","type":"text"}],"type":"emphasis"},{"text":" type, similar to Swift’s builtin ","type":"text"},{"code":"Any","type":"codeVoice"},{"text":" type. Contrary to","type":"text"},{"text":" ","type":"text"},{"code":"Any","type":"codeVoice"},{"text":" the overhead of ","type":"text"},{"code":"NIOAny","type":"codeVoice"},{"text":" depends on the the type of the wrapped value. Certain types that are important","type":"text"},{"text":" ","type":"text"},{"text":"for the performance of a SwiftNIO application like ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":", ","type":"text"},{"code":"FileRegion","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"AddressEnvelope<ByteBuffer>","type":"codeVoice"},{"text":" can be expected","type":"text"},{"text":" ","type":"text"},{"text":"to be wrapped almost without overhead. All others will have similar performance as if they were passed as an ","type":"text"},{"code":"Any","type":"codeVoice"},{"text":" as","type":"text"},{"text":" ","type":"text"},{"code":"NIOAny","type":"codeVoice"},{"text":" just like ","type":"text"},{"code":"Any","type":"codeVoice"},{"text":" will contain them within an existential container.","type":"text"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/SocketOptionValue":{"fragments":[{"text":"typealias","kind":"keyword"},{"text":" ","kind":"text"},{"text":"SocketOptionValue","kind":"identifier"}],"navigatorTitle":[{"text":"SocketOptionValue","kind":"identifier"}],"title":"SocketOptionValue","type":"topic","abstract":[],"kind":"symbol","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/SocketOptionValue","url":"\/documentation\/niocore\/socketoptionvalue"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelError":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelError","type":"topic","abstract":[{"type":"text","text":"An error that can occur on "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" operations."}],"role":"symbol","navigatorTitle":[{"text":"ChannelError","kind":"identifier"}],"title":"ChannelError","fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ChannelError","kind":"identifier"}],"kind":"symbol","url":"\/documentation\/niocore\/channelerror"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/WriteSpinOption":{"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/WriteSpinOption","url":"\/documentation\/niocore\/writespinoption","navigatorTitle":[{"text":"WriteSpinOption","kind":"identifier"}],"type":"topic","title":"WriteSpinOption","abstract":[],"kind":"symbol","deprecated":true,"fragments":[{"text":"typealias","kind":"keyword"},{"text":" ","kind":"text"},{"text":"WriteSpinOption","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/MulticastChannel":{"navigatorTitle":[{"text":"MulticastChannel","kind":"identifier"}],"role":"symbol","kind":"symbol","url":"\/documentation\/niocore\/multicastchannel","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/MulticastChannel","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"MulticastChannel","kind":"identifier"}],"title":"MulticastChannel","type":"topic","abstract":[{"text":"A ","type":"text"},{"code":"MulticastChannel","type":"codeVoice"},{"type":"text","text":" is a "},{"code":"Channel","type":"codeVoice"},{"type":"text","text":" that supports IP multicast operations: that is, a channel that can join multicast"},{"type":"text","text":" "},{"text":"groups.","type":"text"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/BacklogOption":{"fragments":[{"text":"typealias","kind":"keyword"},{"text":" ","kind":"text"},{"text":"BacklogOption","kind":"identifier"}],"type":"topic","deprecated":true,"navigatorTitle":[{"text":"BacklogOption","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/BacklogOption","url":"\/documentation\/niocore\/backlogoption","role":"symbol","title":"BacklogOption","abstract":[],"kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/AcceptBackoffHandler":{"navigatorTitle":[{"kind":"identifier","text":"AcceptBackoffHandler"}],"abstract":[{"type":"text","text":"A "},{"code":"ChannelHandler","type":"codeVoice"},{"type":"text","text":" that implements a backoff for a "},{"type":"codeVoice","code":"ServerChannel"},{"type":"text","text":" when accept produces an "},{"type":"codeVoice","code":"IOError"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"These errors are often recoverable by reducing the rate at which we call accept."}],"role":"symbol","title":"AcceptBackoffHandler","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/AcceptBackoffHandler","kind":"symbol","type":"topic","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"AcceptBackoffHandler"}],"url":"\/documentation\/niocore\/acceptbackoffhandler"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOptions":{"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ChannelOptions"}],"kind":"symbol","url":"\/documentation\/niocore\/channeloptions","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOptions","type":"topic","title":"ChannelOptions","abstract":[{"text":"Provides ","type":"text"},{"code":"ChannelOption","type":"codeVoice"},{"text":"s to be used with a ","type":"text"},{"code":"Channel","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Bootstrap","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"ServerBootstrap","type":"codeVoice"},{"text":".","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"ChannelOptions"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOSendable":{"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOSendable","url":"\/documentation\/niocore\/niosendable","navigatorTitle":[{"kind":"identifier","text":"NIOSendable"}],"type":"topic","title":"NIOSendable","abstract":[],"kind":"symbol","fragments":[{"text":"typealias","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOSendable"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelShouldQuiesceEvent":{"url":"\/documentation\/niocore\/channelshouldquiesceevent","abstract":[{"text":"A ","type":"text"},{"code":"Channel","type":"codeVoice"},{"text":" user event that is sent when the ","type":"text"},{"code":"Channel","type":"codeVoice"},{"text":" has been asked to quiesce.","type":"text"}],"role":"symbol","type":"topic","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"ChannelShouldQuiesceEvent"}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ChannelShouldQuiesceEvent"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelShouldQuiesceEvent","title":"ChannelShouldQuiesceEvent"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/EventLoopPromise":{"type":"topic","abstract":[{"type":"text","text":"A promise to provide a result later."}],"url":"\/documentation\/niocore\/eventlooppromise","title":"EventLoopPromise","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/EventLoopPromise","kind":"symbol","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"EventLoopPromise"}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"EventLoopPromise"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOption":{"url":"\/documentation\/niocore\/channeloption","navigatorTitle":[{"kind":"identifier","text":"ChannelOption"}],"fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ChannelOption"}],"kind":"symbol","type":"topic","abstract":[{"type":"text","text":"A configuration option that can be set on a "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" to configure different behaviour."}],"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOption","title":"ChannelOption"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/SocketOptionName":{"navigatorTitle":[{"kind":"identifier","text":"SocketOptionName"}],"url":"\/documentation\/niocore\/socketoptionname","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/SocketOptionName","abstract":[],"fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"SocketOptionName"}],"title":"SocketOptionName","type":"topic","kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelInboundHandler":{"url":"\/documentation\/niocore\/channelinboundhandler","type":"topic","title":"ChannelInboundHandler","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelInboundHandler","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ChannelInboundHandler"}],"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"ChannelInboundHandler"}],"abstract":[{"code":"ChannelHandler","type":"codeVoice"},{"type":"text","text":" which handles inbound I\/O events for a "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":"."}],"role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/AllowRemoteHalfClosureOption":{"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/AllowRemoteHalfClosureOption","url":"\/documentation\/niocore\/allowremotehalfclosureoption","navigatorTitle":[{"kind":"identifier","text":"AllowRemoteHalfClosureOption"}],"type":"topic","title":"AllowRemoteHalfClosureOption","abstract":[],"kind":"symbol","deprecated":true,"fragments":[{"text":"typealias","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"AllowRemoteHalfClosureOption"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOMulticastNotImplementedError":{"url":"\/documentation\/niocore\/niomulticastnotimplementederror","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOMulticastNotImplementedError","kind":"symbol","role":"symbol","abstract":[{"type":"text","text":"Multicast has not been properly implemented on this channel."}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOMulticastNotImplementedError"}],"title":"NIOMulticastNotImplementedError","navigatorTitle":[{"kind":"identifier","text":"NIOMulticastNotImplementedError"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/MaxMessagesPerReadOption":{"title":"MaxMessagesPerReadOption","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/MaxMessagesPerReadOption","url":"\/documentation\/niocore\/maxmessagesperreadoption","kind":"symbol","role":"symbol","abstract":[],"deprecated":true,"fragments":[{"text":"typealias","kind":"keyword"},{"text":" ","kind":"text"},{"text":"MaxMessagesPerReadOption","kind":"identifier"}],"navigatorTitle":[{"text":"MaxMessagesPerReadOption","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/EventLoopGroup":{"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/EventLoopGroup","navigatorTitle":[{"text":"EventLoopGroup","kind":"identifier"}],"title":"EventLoopGroup","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"EventLoopGroup","kind":"identifier"}],"url":"\/documentation\/niocore\/eventloopgroup","kind":"symbol","type":"topic","abstract":[{"type":"text","text":"Provides an endless stream of "},{"type":"codeVoice","code":"EventLoop"},{"type":"text","text":"s to use."}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/MarkedCircularBuffer":{"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"MarkedCircularBuffer","kind":"identifier"}],"type":"topic","role":"symbol","navigatorTitle":[{"text":"MarkedCircularBuffer","kind":"identifier"}],"kind":"symbol","abstract":[{"text":"A circular buffer that allows one object at a time to be “marked” and easily identified and retrieved later.","type":"text"}],"title":"MarkedCircularBuffer","url":"\/documentation\/niocore\/markedcircularbuffer","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/MarkedCircularBuffer"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOMulticastNotSupportedError":{"type":"topic","kind":"symbol","title":"NIOMulticastNotSupportedError","abstract":[{"type":"text","text":"Multicast is not supported on this interface."}],"navigatorTitle":[{"kind":"identifier","text":"NIOMulticastNotSupportedError"}],"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOMulticastNotSupportedError","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOMulticastNotSupportedError"}],"url":"\/documentation\/niocore\/niomulticastnotsupportederror"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/FixedSizeRecvByteBufferAllocator":{"navigatorTitle":[{"text":"FixedSizeRecvByteBufferAllocator","kind":"identifier"}],"abstract":[{"type":"codeVoice","code":"RecvByteBufferAllocator"},{"type":"text","text":" which will always return a "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" with the same fixed size no matter what was recorded."}],"type":"topic","url":"\/documentation\/niocore\/fixedsizerecvbytebufferallocator","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/FixedSizeRecvByteBufferAllocator","kind":"symbol","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"FixedSizeRecvByteBufferAllocator"}],"title":"FixedSizeRecvByteBufferAllocator"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/EventLoopIterator":{"type":"topic","navigatorTitle":[{"kind":"identifier","text":"EventLoopIterator"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/EventLoopIterator","kind":"symbol","title":"EventLoopIterator","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"EventLoopIterator"}],"abstract":[{"type":"text","text":"An iterator over the "},{"type":"codeVoice","code":"EventLoop"},{"type":"text","text":"s forming an "},{"type":"codeVoice","code":"EventLoopGroup"},{"type":"text","text":"."}],"url":"\/documentation\/niocore\/eventloopiterator","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/WriteObservingByteToMessageDecoder":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/WriteObservingByteToMessageDecoder","navigatorTitle":[{"kind":"identifier","text":"WriteObservingByteToMessageDecoder"}],"abstract":[{"type":"text","text":"Some "},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":"s need to observe "},{"code":"write","type":"codeVoice"},{"text":"s (which are outbound events). ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":"s which","type":"text"},{"text":" ","type":"text"},{"text":"implement the ","type":"text"},{"code":"WriteObservingByteToMessageDecoder","type":"codeVoice"},{"text":" protocol will be notified about every outbound write.","type":"text"}],"url":"\/documentation\/niocore\/writeobservingbytetomessagedecoder","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"WriteObservingByteToMessageDecoder"}],"type":"topic","role":"symbol","title":"WriteObservingByteToMessageDecoder","kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/EventLoopError":{"title":"EventLoopError","kind":"symbol","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"EventLoopError"}],"type":"topic","url":"\/documentation\/niocore\/eventlooperror","role":"symbol","abstract":[{"type":"text","text":"Different "},{"type":"codeVoice","code":"Error"},{"type":"text","text":"s that are specific to "},{"type":"codeVoice","code":"EventLoop"},{"type":"text","text":" operations \/ implementations."}],"navigatorTitle":[{"kind":"identifier","text":"EventLoopError"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/EventLoopError"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/BackPressureHandler":{"kind":"symbol","abstract":[{"type":"text","text":"ChannelHandler implementation which enforces back-pressure by stopping to read from the remote peer when it cannot write back fast enough."},{"type":"text","text":" "},{"type":"text","text":"It will start reading again once pending data was written."}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/BackPressureHandler","type":"topic","title":"BackPressureHandler","url":"\/documentation\/niocore\/backpressurehandler","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"BackPressureHandler"}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"BackPressureHandler"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/RecvAllocatorOption":{"role":"symbol","title":"RecvAllocatorOption","navigatorTitle":[{"kind":"identifier","text":"RecvAllocatorOption"}],"fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"RecvAllocatorOption"}],"deprecated":true,"abstract":[],"url":"\/documentation\/niocore\/recvallocatoroption","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RecvAllocatorOption","kind":"symbol","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/Scheduled":{"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Scheduled","kind":"identifier"}],"url":"\/documentation\/niocore\/scheduled","kind":"symbol","navigatorTitle":[{"text":"Scheduled","kind":"identifier"}],"abstract":[{"type":"text","text":"Returned once a task was scheduled on the "},{"type":"codeVoice","code":"EventLoop"},{"type":"text","text":" for later execution."}],"role":"symbol","type":"topic","title":"Scheduled","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/Scheduled"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOutboundHandler":{"navigatorTitle":[{"kind":"identifier","text":"ChannelOutboundHandler"}],"abstract":[{"code":"ChannelHandler","type":"codeVoice"},{"type":"text","text":" which handles outbound I\/O events or intercept an outbound I\/O operation for a "},{"code":"Channel","type":"codeVoice"},{"type":"text","text":"."}],"role":"symbol","title":"ChannelOutboundHandler","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOutboundHandler","kind":"symbol","type":"topic","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ChannelOutboundHandler"}],"url":"\/documentation\/niocore\/channeloutboundhandler"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelDuplexHandler":{"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelDuplexHandler","url":"\/documentation\/niocore\/channelduplexhandler","navigatorTitle":[{"kind":"identifier","text":"ChannelDuplexHandler"}],"type":"topic","title":"ChannelDuplexHandler","abstract":[{"text":"A combination of ","type":"text"},{"type":"codeVoice","code":"ChannelInboundHandler"},{"type":"text","text":" and "},{"type":"codeVoice","code":"ChannelOutboundHandler"},{"type":"text","text":"."}],"kind":"symbol","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"ChannelDuplexHandler"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/Endianness":{"fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Endianness","kind":"identifier"}],"url":"\/documentation\/niocore\/endianness","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/Endianness","role":"symbol","navigatorTitle":[{"text":"Endianness","kind":"identifier"}],"kind":"symbol","abstract":[{"text":"Endianness refers to the sequential order in which bytes are arranged into larger numerical values when stored in","type":"text"},{"text":" ","type":"text"},{"text":"memory or when transmitted over digital links.","type":"text"}],"type":"topic","title":"Endianness"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIONetworkInterface":{"title":"NIONetworkInterface","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIONetworkInterface","type":"topic","deprecated":true,"abstract":[{"text":"A representation of a single network interface on a system.","type":"text"}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIONetworkInterface"}],"url":"\/documentation\/niocore\/nionetworkinterface","kind":"symbol","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"NIONetworkInterface"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageHandler":{"kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageHandler","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ByteToMessageHandler"}],"title":"ByteToMessageHandler","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ByteToMessageHandler"}],"role":"symbol","abstract":[{"text":"A handler which turns a given ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" into a ","type":"text"},{"type":"codeVoice","code":"ChannelInboundHandler"},{"text":" that can then be added to a","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"ChannelPipeline"},{"text":".","type":"text"}],"url":"\/documentation\/niocore\/bytetomessagehandler"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelPipelineError":{"title":"ChannelPipelineError","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"ChannelPipelineError"}],"url":"\/documentation\/niocore\/channelpipelineerror","kind":"symbol","type":"topic","abstract":[{"type":"codeVoice","code":"Error"},{"type":"text","text":" that is used by the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":" to inform the user of an error."}],"navigatorTitle":[{"kind":"identifier","text":"ChannelPipelineError"}],"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelPipelineError"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelOutboundInvoker":{"navigatorTitle":[{"kind":"identifier","text":"ChannelOutboundInvoker"}],"title":"ChannelOutboundInvoker","url":"\/documentation\/niocore\/channeloutboundinvoker","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelOutboundInvoker","abstract":[{"text":"Allows users to invoke an “outbound” operation related to a ","type":"text"},{"code":"Channel","type":"codeVoice"},{"text":" that will flow through the ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":" until","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"it will finally be executed by the the "},{"code":"ChannelCore","type":"codeVoice"},{"type":"text","text":" implementation."}],"role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ChannelOutboundInvoker"}],"kind":"symbol","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIONetworkDevice":{"type":"topic","abstract":[{"text":"A representation of a single network device on a system.","type":"text"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIONetworkDevice","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIONetworkDevice","kind":"symbol","url":"\/documentation\/niocore\/nionetworkdevice","navigatorTitle":[{"text":"NIONetworkDevice","kind":"identifier"}],"title":"NIONetworkDevice","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/DatagramChannelError":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/DatagramChannelError","type":"topic","abstract":[],"url":"\/documentation\/niocore\/datagramchannelerror","title":"DatagramChannelError","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"DatagramChannelError"}],"kind":"symbol","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"DatagramChannelError"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/DecodingState":{"kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/DecodingState","title":"DecodingState","navigatorTitle":[{"text":"DecodingState","kind":"identifier"}],"fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"text":"DecodingState","kind":"identifier"}],"abstract":[{"text":"State of the current decoding process.","type":"text"}],"url":"\/documentation\/niocore\/decodingstate","type":"topic","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/AdaptiveRecvByteBufferAllocator":{"kind":"symbol","type":"topic","abstract":[{"type":"codeVoice","code":"RecvByteBufferAllocator"},{"type":"text","text":" which will gracefully increment or decrement the buffer size on the feedback that was recorded."}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AdaptiveRecvByteBufferAllocator","kind":"identifier"}],"url":"\/documentation\/niocore\/adaptiverecvbytebufferallocator","role":"symbol","title":"AdaptiveRecvByteBufferAllocator","navigatorTitle":[{"text":"AdaptiveRecvByteBufferAllocator","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/AdaptiveRecvByteBufferAllocator"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder":{"kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder","title":"ByteToMessageDecoder","navigatorTitle":[{"text":"ByteToMessageDecoder","kind":"identifier"}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ByteToMessageDecoder","kind":"identifier"}],"abstract":[{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":"s decode bytes in a stream-like fashion from ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":" to another message type.","type":"text"}],"url":"\/documentation\/niocore\/bytetomessagedecoder","type":"topic","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOAttemptedToRemoveHandlerMultipleTimesError":{"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"NIOAttemptedToRemoveHandlerMultipleTimesError"}],"abstract":[{"type":"text","text":"The removal of a "},{"code":"ChannelHandler","type":"codeVoice"},{"type":"text","text":" using "},{"code":"ChannelPipeline.removeHandler","type":"codeVoice"},{"type":"text","text":" has been attempted more than once."}],"url":"\/documentation\/niocore\/nioattemptedtoremovehandlermultipletimeserror","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOAttemptedToRemoveHandlerMultipleTimesError"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOAttemptedToRemoveHandlerMultipleTimesError","type":"topic","role":"symbol","title":"NIOAttemptedToRemoveHandlerMultipleTimesError"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOPOSIXFileMode":{"title":"NIOPOSIXFileMode","role":"symbol","url":"\/documentation\/niocore\/nioposixfilemode","abstract":[],"type":"topic","fragments":[{"text":"typealias","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOPOSIXFileMode","kind":"identifier"}],"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"NIOPOSIXFileMode"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOPOSIXFileMode"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelHandler":{"navigatorTitle":[{"kind":"identifier","text":"ChannelHandler"}],"url":"\/documentation\/niocore\/channelhandler","title":"ChannelHandler","abstract":[{"text":"You should ","type":"text"},{"inlineContent":[{"type":"text","text":"never"}],"type":"emphasis"},{"text":" implement this protocol directly. Please implement one of its sub-protocols.","type":"text"}],"type":"topic","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ChannelHandler"}],"kind":"symbol","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelHandler"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOSingleStepByteToMessageProcessor":{"role":"symbol","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"NIOSingleStepByteToMessageProcessor"}],"abstract":[{"type":"codeVoice","code":"NIOSingleStepByteToMessageProcessor"},{"type":"text","text":" uses a "},{"type":"codeVoice","code":"NIOSingleStepByteToMessageDecoder"},{"type":"text","text":" to produce messages"},{"type":"text","text":" "},{"type":"text","text":"from a stream of incoming bytes. It works like "},{"code":"ByteToMessageHandler","type":"codeVoice"},{"type":"text","text":" but may be used outside of the channel pipeline. This allows"},{"type":"text","text":" "},{"type":"text","text":"processing of wrapped protocols in a general way."}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOSingleStepByteToMessageProcessor"}],"type":"topic","title":"NIOSingleStepByteToMessageProcessor","url":"\/documentation\/niocore\/niosinglestepbytetomessageprocessor","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOSingleStepByteToMessageProcessor"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteBufferAllocator":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteBufferAllocator","url":"\/documentation\/niocore\/bytebufferallocator","type":"topic","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ByteBufferAllocator"}],"title":"ByteBufferAllocator","navigatorTitle":[{"kind":"identifier","text":"ByteBufferAllocator"}],"abstract":[{"text":"The preferred allocator for ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":" values. The allocation strategy is opaque but is currently libc’s","type":"text"},{"text":" ","type":"text"},{"code":"malloc","type":"codeVoice"},{"text":", ","type":"text"},{"code":"realloc","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"free","type":"codeVoice"},{"text":".","type":"text"}],"role":"symbol","kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/WriteBufferWaterMark":{"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/WriteBufferWaterMark","url":"\/documentation\/niocore\/writebufferwatermark","navigatorTitle":[{"kind":"identifier","text":"WriteBufferWaterMark"}],"type":"topic","title":"WriteBufferWaterMark","abstract":[],"kind":"symbol","deprecated":true,"fragments":[{"text":"typealias","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"WriteBufferWaterMark"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelEvent":{"fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ChannelEvent","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelEvent","navigatorTitle":[{"text":"ChannelEvent","kind":"identifier"}],"role":"symbol","url":"\/documentation\/niocore\/channelevent","abstract":[{"text":"An ","type":"text"},{"type":"codeVoice","code":"Channel"},{"text":" related event that is passed through the ","type":"text"},{"type":"codeVoice","code":"ChannelPipeline"},{"text":" to notify the user.","type":"text"}],"kind":"symbol","type":"topic","title":"ChannelEvent"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteBufferView":{"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ByteBufferView","kind":"identifier"}],"role":"symbol","navigatorTitle":[{"text":"ByteBufferView","kind":"identifier"}],"kind":"symbol","abstract":[{"type":"text","text":"A view into a portion of a "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":"."}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteBufferView","title":"ByteBufferView","type":"topic","url":"\/documentation\/niocore\/bytebufferview"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOSingleStepByteToMessageDecoder":{"type":"topic","kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOSingleStepByteToMessageDecoder","kind":"identifier"}],"abstract":[{"type":"text","text":"A simplified version of "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" that can generate zero or one messages for each invocation of "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" or "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Having "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" and "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" return an optional message avoids re-entrancy problems, since the functions relinquish exclusive access"},{"type":"text","text":" "},{"type":"text","text":"to the "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" when returning. This allows for greatly simplified processing."}],"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOSingleStepByteToMessageDecoder","url":"\/documentation\/niocore\/niosinglestepbytetomessagedecoder","navigatorTitle":[{"text":"NIOSingleStepByteToMessageDecoder","kind":"identifier"}],"title":"NIOSingleStepByteToMessageDecoder"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOInsecureNoTLS":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOInsecureNoTLS","role":"symbol","url":"\/documentation\/niocore\/nioinsecurenotls","kind":"symbol","abstract":[],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOInsecureNoTLS"}],"type":"topic","navigatorTitle":[{"kind":"identifier","text":"NIOInsecureNoTLS"}],"title":"NIOInsecureNoTLS"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteBuffer":{"kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteBuffer","navigatorTitle":[{"kind":"identifier","text":"ByteBuffer"}],"title":"ByteBuffer","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ByteBuffer"}],"role":"symbol","url":"\/documentation\/niocore\/bytebuffer","abstract":[{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":" stores contiguously allocated raw bytes. It is a random and sequential accessible sequence of zero or"},{"type":"text","text":" "},{"type":"text","text":"more bytes (octets)."}],"type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/RemovableChannelHandler":{"role":"symbol","url":"\/documentation\/niocore\/removablechannelhandler","abstract":[{"text":"A ","type":"text"},{"type":"codeVoice","code":"RemovableChannelHandler"},{"text":" is a ","type":"text"},{"type":"codeVoice","code":"ChannelHandler"},{"text":" that can be dynamically removed from a ","type":"text"},{"type":"codeVoice","code":"ChannelPipeline"},{"text":" whilst","type":"text"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"code":"Channel","type":"codeVoice"},{"text":" is operating normally.","type":"text"},{"text":" ","type":"text"},{"text":"A ","type":"text"},{"code":"RemovableChannelHandler","type":"codeVoice"},{"text":" is required to remove itself from the ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":" (using","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"ChannelHandlerContext.removeHandler"},{"text":") as soon as possible.","type":"text"}],"fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"RemovableChannelHandler"}],"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RemovableChannelHandler","navigatorTitle":[{"kind":"identifier","text":"RemovableChannelHandler"}],"title":"RemovableChannelHandler","kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelInvoker":{"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ChannelInvoker","kind":"identifier"}],"role":"symbol","title":"ChannelInvoker","url":"\/documentation\/niocore\/channelinvoker","kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelInvoker","abstract":[{"type":"text","text":"A protocol that signals that outbound and inbound events are triggered by this invoker."}],"navigatorTitle":[{"text":"ChannelInvoker","kind":"identifier"}],"type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/SocketOption":{"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/SocketOption","url":"\/documentation\/niocore\/socketoption","navigatorTitle":[{"kind":"identifier","text":"SocketOption"}],"type":"topic","title":"SocketOption","abstract":[],"kind":"symbol","deprecated":true,"fragments":[{"text":"typealias","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"SocketOption"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/RepeatedTask":{"type":"topic","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"RepeatedTask","kind":"identifier"}],"title":"RepeatedTask","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RepeatedTask","url":"\/documentation\/niocore\/repeatedtask","navigatorTitle":[{"text":"RepeatedTask","kind":"identifier"}],"role":"symbol","kind":"symbol","abstract":[{"type":"text","text":"Returned once a task was scheduled to be repeatedly executed on the "},{"code":"EventLoop","type":"codeVoice"},{"type":"text","text":"."}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelInboundInvoker":{"title":"ChannelInboundInvoker","url":"\/documentation\/niocore\/channelinboundinvoker","role":"symbol","kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelInboundInvoker","type":"topic","navigatorTitle":[{"text":"ChannelInboundInvoker","kind":"identifier"}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ChannelInboundInvoker","kind":"identifier"}],"abstract":[{"type":"text","text":"Fire inbound events related to a "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" through the "},{"type":"codeVoice","code":"ChannelPipeline"},{"text":" until its end is reached or it’s consumed by a ","type":"text"},{"code":"ChannelHandler","type":"codeVoice"},{"text":".","type":"text"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/WriteBufferWaterMarkOption":{"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/WriteBufferWaterMarkOption","url":"\/documentation\/niocore\/writebufferwatermarkoption","navigatorTitle":[{"kind":"identifier","text":"WriteBufferWaterMarkOption"}],"type":"topic","title":"WriteBufferWaterMarkOption","abstract":[],"kind":"symbol","deprecated":true,"fragments":[{"text":"typealias","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"WriteBufferWaterMarkOption"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoderError":{"abstract":[{"text":"Common errors thrown by ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":"s.","type":"text"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoderError","role":"symbol","fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ByteToMessageDecoderError","kind":"identifier"}],"title":"ByteToMessageDecoderError","type":"topic","navigatorTitle":[{"text":"ByteToMessageDecoderError","kind":"identifier"}],"kind":"symbol","url":"\/documentation\/niocore\/bytetomessagedecodererror"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/RecvByteBufferAllocator":{"navigatorTitle":[{"kind":"identifier","text":"RecvByteBufferAllocator"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RecvByteBufferAllocator","kind":"symbol","url":"\/documentation\/niocore\/recvbytebufferallocator","type":"topic","role":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"RecvByteBufferAllocator"}],"title":"RecvByteBufferAllocator","abstract":[{"text":"Allocates ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":"s to be used to read bytes from a "},{"type":"codeVoice","code":"Channel"},{"text":" and records the number of the actual bytes that were used.","type":"text"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOClientTCPBootstrap":{"type":"topic","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOClientTCPBootstrap","kind":"identifier"}],"role":"symbol","url":"\/documentation\/niocore\/nioclienttcpbootstrap","title":"NIOClientTCPBootstrap","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOClientTCPBootstrap","kind":"symbol","abstract":[{"type":"codeVoice","code":"NIOClientTCPBootstrap"},{"type":"text","text":" is a bootstrap that allows you to bootstrap client TCP connections using NIO on BSD Sockets,"},{"text":" ","type":"text"},{"text":"NIO Transport Services, or other ways.","type":"text"}],"navigatorTitle":[{"text":"NIOClientTCPBootstrap","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/IdleStateHandler":{"navigatorTitle":[{"kind":"identifier","text":"IdleStateHandler"}],"url":"\/documentation\/niocore\/idlestatehandler","title":"IdleStateHandler","abstract":[{"text":"Triggers an IdleStateEvent when a Channel has not performed read, write, or both operation for a while.","type":"text"}],"type":"topic","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"IdleStateHandler"}],"kind":"symbol","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/IdleStateHandler"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOSynchronousChannelOptions":{"abstract":[],"type":"topic","url":"\/documentation\/niocore\/niosynchronouschanneloptions","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOSynchronousChannelOptions"}],"role":"symbol","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"NIOSynchronousChannelOptions"}],"title":"NIOSynchronousChannelOptions","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOSynchronousChannelOptions"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelHandlerContext":{"title":"ChannelHandlerContext","role":"symbol","type":"topic","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"ChannelHandlerContext"}],"navigatorTitle":[{"kind":"identifier","text":"ChannelHandlerContext"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelHandlerContext","kind":"symbol","url":"\/documentation\/niocore\/channelhandlercontext","abstract":[{"type":"text","text":"Every "},{"code":"ChannelHandler","type":"codeVoice"},{"text":" has – when added to a ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":" – a corresponding ","type":"text"},{"code":"ChannelHandlerContext","type":"codeVoice"},{"text":" which is","type":"text"},{"text":" ","type":"text"},{"text":"the way ","type":"text"},{"code":"ChannelHandler","type":"codeVoice"},{"text":"s can interact with other ","type":"text"},{"code":"ChannelHandler","type":"codeVoice"},{"text":"s in the pipeline.","type":"text"}]}}}