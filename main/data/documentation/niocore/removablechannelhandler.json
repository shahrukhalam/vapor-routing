{"metadata":{"symbolKind":"protocol","title":"RemovableChannelHandler","externalID":"s:7NIOCore23RemovableChannelHandlerP","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"RemovableChannelHandler","kind":"identifier"}],"navigatorTitle":[{"text":"RemovableChannelHandler","kind":"identifier"}],"roleHeading":"Protocol","role":"symbol","modules":[{"name":"NIOCore"}]},"hierarchy":{"paths":[["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore"]]},"kind":"symbol","primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"RemovableChannelHandler"},{"kind":"text","text":" : "},{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelHandler","preciseIdentifier":"s:7NIOCore14ChannelHandlerP","kind":"typeIdentifier","text":"ChannelHandler"}],"languages":["swift"],"platforms":["Linux"]}]},{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"name":"Note","style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"When a "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":" gets torn down, every "},{"type":"codeVoice","code":"ChannelHandler"},{"type":"text","text":" in the "},{"type":"codeVoice","code":"Channel"},{"type":"text","text":"’s "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":" will be"},{"type":"text","text":" "},{"type":"text","text":"removed from the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":". Those removals however happen synchronously and are not going through"},{"type":"text","text":" "},{"type":"text","text":"the methods of this protocol."}]}]}]}],"abstract":[{"type":"text","text":"A "},{"code":"RemovableChannelHandler","type":"codeVoice"},{"type":"text","text":" is a "},{"code":"ChannelHandler","type":"codeVoice"},{"type":"text","text":" that can be dynamically removed from a "},{"code":"ChannelPipeline","type":"codeVoice"},{"type":"text","text":" whilst"},{"type":"text","text":" "},{"type":"text","text":"the "},{"code":"Channel","type":"codeVoice"},{"type":"text","text":" is operating normally."},{"type":"text","text":" "},{"type":"text","text":"A "},{"code":"RemovableChannelHandler","type":"codeVoice"},{"type":"text","text":" is required to remove itself from the "},{"code":"ChannelPipeline","type":"codeVoice"},{"type":"text","text":" (using"},{"type":"text","text":" "},{"code":"ChannelHandlerContext.removeHandler","type":"codeVoice"},{"type":"text","text":") as soon as possible."}],"identifier":{"url":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RemovableChannelHandler","interfaceLanguage":"swift"},"sections":[],"topicSections":[{"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RemovableChannelHandler\/removeHandler(context:removalToken:)-2jaoc"],"title":"Instance Methods"}],"variants":[{"paths":["\/documentation\/niocore\/removablechannelhandler"],"traits":[{"interfaceLanguage":"swift"}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"relationshipsSections":[{"kind":"relationships","type":"inheritsFrom","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelHandler"],"title":"Inherits From"},{"kind":"relationships","type":"conformingTypes","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/AcceptBackoffHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOTLS\/ApplicationProtocolNegotiationHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/BackPressureHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPRequestEncoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/HTTPResponseCompressor","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPResponseEncoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerPipelineHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerProtocolErrorHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerUpgradeHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/IdleStateHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPClientResponseAggregator","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPClientUpgradeHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPRequestCompressor","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPRequestDecompressor","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPRequestHeadersValidator","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPResponseDecompressor","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPResponseHeadersValidator","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPServerRequestAggregator","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLClientHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLServerHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOWritePCAPHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/SOCKSClientHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/SOCKSServerHandshakeHandler"],"title":"Conforming Types"}],"references":{"doc://co.pointfree.VaporRouting/documentation/NIOSSL/NIOSSLHandler":{"navigatorTitle":[{"kind":"identifier","text":"NIOSSLHandler"}],"url":"\/documentation\/niossl\/niosslhandler","title":"NIOSSLHandler","abstract":[{"text":"The base class for all NIOSSL handlers.","type":"text"}],"type":"topic","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOSSLHandler"}],"kind":"symbol","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLHandler"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/RemovableChannelHandler/removeHandler(context:removalToken:)-2jaoc":{"kind":"symbol","required":true,"defaultImplementations":1,"fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"removeHandler"},{"kind":"text","text":"("},{"kind":"externalParam","text":"context"},{"kind":"text","text":": "},{"preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC","kind":"typeIdentifier","text":"ChannelHandlerContext"},{"kind":"text","text":", "},{"kind":"externalParam","text":"removalToken"},{"kind":"text","text":": "},{"preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC","kind":"typeIdentifier","text":"ChannelHandlerContext"},{"kind":"text","text":"."},{"preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC12RemovalTokenV","text":"RemovalToken","kind":"typeIdentifier"},{"text":")","kind":"text"}],"title":"removeHandler(context:removalToken:)","abstract":[{"type":"text","text":"Ask the receiving "},{"type":"codeVoice","code":"RemovableChannelHandler"},{"text":" to remove itself from the ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":" as soon as possible.","type":"text"},{"text":" ","type":"text"},{"text":"The receiving ","type":"text"},{"code":"RemovableChannelHandler","type":"codeVoice"},{"type":"text","text":" may elect to remove itself sometime after this method call, rather than"},{"type":"text","text":" "},{"type":"text","text":"immediately, but if it does so it must take the necessary precautions to handle events arriving between the"},{"type":"text","text":" "},{"type":"text","text":"invocation of this method and the call to "},{"type":"codeVoice","code":"ChannelHandlerContext.removeHandler"},{"type":"text","text":" that triggers the actual"},{"type":"text","text":" "},{"type":"text","text":"removal."}],"type":"topic","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RemovableChannelHandler\/removeHandler(context:removalToken:)-2jaoc","url":"\/documentation\/niocore\/removablechannelhandler\/removehandler(context:removaltoken:)-2jaoc"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTPCompression/NIOHTTPRequestCompressor":{"kind":"symbol","abstract":[{"type":"reference","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPRequestCompressor","isActive":true},{"type":"text","text":" is an outbound channel handler that handles automatic streaming compression of"},{"type":"text","text":" "},{"type":"text","text":"HTTP requests."}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPRequestCompressor","type":"topic","title":"NIOHTTPRequestCompressor","url":"\/documentation\/niohttpcompression\/niohttprequestcompressor","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"NIOHTTPRequestCompressor"}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOHTTPRequestCompressor"}]},"doc://co.pointfree.VaporRouting/documentation/NIOHTTPCompression/NIOHTTPRequestDecompressor":{"kind":"symbol","abstract":[{"type":"text","text":"Channel hander to decompress incoming HTTP data."}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPRequestDecompressor","type":"topic","title":"NIOHTTPRequestDecompressor","url":"\/documentation\/niohttpcompression\/niohttprequestdecompressor","role":"symbol","navigatorTitle":[{"text":"NIOHTTPRequestDecompressor","kind":"identifier"}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"text":"NIOHTTPRequestDecompressor","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/NIOHTTPServerRequestAggregator":{"type":"topic","navigatorTitle":[{"text":"NIOHTTPServerRequestAggregator","kind":"identifier"}],"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPServerRequestAggregator","kind":"symbol","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOHTTPServerRequestAggregator","kind":"identifier"}],"title":"NIOHTTPServerRequestAggregator","url":"\/documentation\/niohttp1\/niohttpserverrequestaggregator","abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ChannelInboundHandler"},{"type":"text","text":" that handles HTTP chunked "},{"type":"codeVoice","code":"HTTPServerRequestPart"},{"type":"text","text":" "},{"text":"messages by aggregating individual message chunks into a single","type":"text"},{"text":" ","type":"text"},{"code":"NIOHTTPServerRequestFull","type":"codeVoice"},{"text":".","type":"text"}]},"doc://co.pointfree.VaporRouting/documentation/NIOSOCKS/SOCKSServerHandshakeHandler":{"navigatorTitle":[{"kind":"identifier","text":"SOCKSServerHandshakeHandler"}],"url":"\/documentation\/niosocks\/socksserverhandshakehandler","title":"SOCKSServerHandshakeHandler","abstract":[{"text":"Add this handshake handler to the front of your channel, closest to the network.","type":"text"},{"text":" ","type":"text"},{"text":"The handler will receive bytes from the network and run them through a state machine","type":"text"},{"text":" ","type":"text"},{"text":"and parser to enforce SOCKSv5 protocol correctness. Inbound bytes will by parsed into","type":"text"},{"text":" ","type":"text"},{"isActive":true,"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/ClientMessage","type":"reference"},{"text":" for downstream consumption. Send ","type":"text"},{"isActive":true,"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/ServerMessage","type":"reference"},{"text":" to this","type":"text"},{"text":" ","type":"text"},{"text":"handler.","type":"text"}],"type":"topic","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"SOCKSServerHandshakeHandler"}],"kind":"symbol","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/SOCKSServerHandshakeHandler"},"doc://co.pointfree.VaporRouting/documentation/NIOTLS/ApplicationProtocolNegotiationHandler":{"type":"topic","abstract":[{"type":"text","text":"A helper "},{"code":"ChannelInboundHandler","type":"codeVoice"},{"type":"text","text":" that makes it easy to swap channel pipelines"},{"type":"text","text":" "},{"type":"text","text":"based on the result of an ALPN negotiation."}],"kind":"symbol","url":"\/documentation\/niotls\/applicationprotocolnegotiationhandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ApplicationProtocolNegotiationHandler","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOTLS\/ApplicationProtocolNegotiationHandler","navigatorTitle":[{"text":"ApplicationProtocolNegotiationHandler","kind":"identifier"}],"role":"symbol","title":"ApplicationProtocolNegotiationHandler"},"doc://co.pointfree.VaporRouting/documentation/NIOSOCKS/SOCKSClientHandler":{"navigatorTitle":[{"kind":"identifier","text":"SOCKSClientHandler"}],"url":"\/documentation\/niosocks\/socksclienthandler","title":"SOCKSClientHandler","abstract":[{"text":"Connects to a SOCKS server to establish a proxied connection","type":"text"},{"text":" ","type":"text"},{"text":"to a host. This handler should be inserted at the beginning of a","type":"text"},{"text":" ","type":"text"},{"text":"channel’s pipeline. Note that SOCKS only supports fully-qualified","type":"text"},{"text":" ","type":"text"},{"text":"domain names and IPv4 or IPv6 sockets, and not UNIX sockets.","type":"text"}],"type":"topic","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"SOCKSClientHandler"}],"kind":"symbol","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/SOCKSClientHandler"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/NIOHTTPRequestHeadersValidator":{"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"NIOHTTPRequestHeadersValidator"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPRequestHeadersValidator","type":"topic","url":"\/documentation\/niohttp1\/niohttprequestheadersvalidator","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOHTTPRequestHeadersValidator"}],"title":"NIOHTTPRequestHeadersValidator","abstract":[{"type":"text","text":"A ChannelHandler to validate that outbound request headers are spec-compliant."}],"role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOSOCKS/ClientMessage":{"navigatorTitle":[{"kind":"identifier","text":"ClientMessage"}],"url":"\/documentation\/niosocks\/clientmessage","title":"ClientMessage","abstract":[{"text":"Sent by the client and received by the server.","type":"text"}],"type":"topic","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"ClientMessage"}],"kind":"symbol","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/ClientMessage"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/RemovableChannelHandler":{"role":"symbol","url":"\/documentation\/niocore\/removablechannelhandler","abstract":[{"text":"A ","type":"text"},{"type":"codeVoice","code":"RemovableChannelHandler"},{"text":" is a ","type":"text"},{"type":"codeVoice","code":"ChannelHandler"},{"text":" that can be dynamically removed from a ","type":"text"},{"type":"codeVoice","code":"ChannelPipeline"},{"text":" whilst","type":"text"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"code":"Channel","type":"codeVoice"},{"text":" is operating normally.","type":"text"},{"text":" ","type":"text"},{"text":"A ","type":"text"},{"code":"RemovableChannelHandler","type":"codeVoice"},{"text":" is required to remove itself from the ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":" (using","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"ChannelHandlerContext.removeHandler"},{"text":") as soon as possible.","type":"text"}],"fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"RemovableChannelHandler"}],"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/RemovableChannelHandler","navigatorTitle":[{"kind":"identifier","text":"RemovableChannelHandler"}],"title":"RemovableChannelHandler","kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ChannelHandler":{"navigatorTitle":[{"kind":"identifier","text":"ChannelHandler"}],"url":"\/documentation\/niocore\/channelhandler","title":"ChannelHandler","abstract":[{"text":"You should ","type":"text"},{"inlineContent":[{"type":"text","text":"never"}],"type":"emphasis"},{"text":" implement this protocol directly. Please implement one of its sub-protocols.","type":"text"}],"type":"topic","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ChannelHandler"}],"kind":"symbol","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ChannelHandler"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/NIOHTTPClientResponseAggregator":{"type":"topic","abstract":[{"type":"text","text":"A "},{"code":"ChannelInboundHandler","type":"codeVoice"},{"type":"text","text":" that handles HTTP chunked "},{"code":"HTTPClientResponsePart","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"messages by aggregating individual message chunks into a single"},{"type":"text","text":" "},{"code":"NIOHTTPClientResponseFull","type":"codeVoice"},{"type":"text","text":"."}],"kind":"symbol","url":"\/documentation\/niohttp1\/niohttpclientresponseaggregator","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOHTTPClientResponseAggregator","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPClientResponseAggregator","navigatorTitle":[{"text":"NIOHTTPClientResponseAggregator","kind":"identifier"}],"role":"symbol","title":"NIOHTTPClientResponseAggregator"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/NIOWritePCAPHandler":{"navigatorTitle":[{"kind":"identifier","text":"NIOWritePCAPHandler"}],"abstract":[{"type":"text","text":"A "},{"code":"ChannelHandler","type":"codeVoice"},{"type":"text","text":" that can write a "},{"identifier":"https:\/\/en.wikipedia.org\/wiki\/Pcap","type":"reference","isActive":true},{"type":"text","text":" containing the send\/received"},{"type":"text","text":" "},{"type":"text","text":"data as synthesized TCP packet captures."}],"role":"symbol","title":"NIOWritePCAPHandler","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOWritePCAPHandler","kind":"symbol","type":"topic","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOWritePCAPHandler"}],"url":"\/documentation\/nioextras\/niowritepcaphandler"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/AcceptBackoffHandler":{"navigatorTitle":[{"kind":"identifier","text":"AcceptBackoffHandler"}],"abstract":[{"type":"text","text":"A "},{"code":"ChannelHandler","type":"codeVoice"},{"type":"text","text":" that implements a backoff for a "},{"type":"codeVoice","code":"ServerChannel"},{"type":"text","text":" when accept produces an "},{"type":"codeVoice","code":"IOError"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"These errors are often recoverable by reducing the rate at which we call accept."}],"role":"symbol","title":"AcceptBackoffHandler","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/AcceptBackoffHandler","kind":"symbol","type":"topic","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"AcceptBackoffHandler"}],"url":"\/documentation\/niocore\/acceptbackoffhandler"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/NIOHTTPClientUpgradeHandler":{"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"NIOHTTPClientUpgradeHandler"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPClientUpgradeHandler","type":"topic","url":"\/documentation\/niohttp1\/niohttpclientupgradehandler","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOHTTPClientUpgradeHandler"}],"title":"NIOHTTPClientUpgradeHandler","abstract":[{"type":"text","text":"A client-side channel handler that sends a HTTP upgrade handshake request to perform a HTTP-upgrade."},{"type":"text","text":" "},{"type":"text","text":"When the first HTTP request is sent, this handler will add all appropriate headers to perform an upgrade to"},{"type":"text","text":" "},{"type":"text","text":"the a protocol. It may add headers for a set of protocols in preference order."},{"type":"text","text":" "},{"type":"text","text":"If the upgrade fails (i.e. response is not 101 Switching Protocols), this handler simply"},{"type":"text","text":" "},{"type":"text","text":"removes itself from the pipeline. If the upgrade is successful, it upgrades the pipeline to the new protocol."}],"role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOSSL/NIOSSLServerHandler":{"navigatorTitle":[{"kind":"identifier","text":"NIOSSLServerHandler"}],"abstract":[{"type":"text","text":"A channel handler that wraps a channel in TLS using NIOSSL. This"},{"type":"text","text":" "},{"type":"text","text":"handler can be used in channels that are acting as the server in"},{"type":"text","text":" "},{"type":"text","text":"the TLS dialog. For client connections, use the "},{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLClientHandler","type":"reference","isActive":true},{"type":"text","text":"."}],"role":"symbol","title":"NIOSSLServerHandler","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLServerHandler","kind":"symbol","type":"topic","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOSSLServerHandler"}],"url":"\/documentation\/niossl\/niosslserverhandler"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/BackPressureHandler":{"kind":"symbol","abstract":[{"type":"text","text":"ChannelHandler implementation which enforces back-pressure by stopping to read from the remote peer when it cannot write back fast enough."},{"type":"text","text":" "},{"type":"text","text":"It will start reading again once pending data was written."}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/BackPressureHandler","type":"topic","title":"BackPressureHandler","url":"\/documentation\/niocore\/backpressurehandler","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"BackPressureHandler"}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"BackPressureHandler"}]},"doc://co.pointfree.VaporRouting/documentation/NIOSSL/NIOSSLClientHandler":{"navigatorTitle":[{"kind":"identifier","text":"NIOSSLClientHandler"}],"url":"\/documentation\/niossl\/niosslclienthandler","title":"NIOSSLClientHandler","abstract":[{"text":"A channel handler that wraps a channel in TLS using NIOSSL.","type":"text"},{"text":" ","type":"text"},{"text":"This handler can be used in channels that are acting as the client","type":"text"},{"text":" ","type":"text"},{"text":"in the TLS dialog. For server connections, use the ","type":"text"},{"isActive":true,"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLServerHandler","type":"reference"},{"text":".","type":"text"}],"type":"topic","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOSSLClientHandler"}],"kind":"symbol","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSSL\/NIOSSLClientHandler"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPRequestEncoder":{"navigatorTitle":[{"kind":"identifier","text":"HTTPRequestEncoder"}],"abstract":[{"type":"text","text":"A "},{"code":"ChannelOutboundHandler","type":"codeVoice"},{"type":"text","text":" that can serialize HTTP requests."}],"role":"symbol","title":"HTTPRequestEncoder","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPRequestEncoder","kind":"symbol","type":"topic","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"HTTPRequestEncoder"}],"url":"\/documentation\/niohttp1\/httprequestencoder"},"doc://co.pointfree.VaporRouting/documentation/NIOSOCKS/ServerMessage":{"navigatorTitle":[{"kind":"identifier","text":"ServerMessage"}],"abstract":[{"type":"text","text":"Sent by the server and received by the client."}],"role":"symbol","title":"ServerMessage","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOSOCKS\/ServerMessage","kind":"symbol","type":"topic","fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"ServerMessage"}],"url":"\/documentation\/niosocks\/servermessage"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPServerPipelineHandler":{"navigatorTitle":[{"kind":"identifier","text":"HTTPServerPipelineHandler"}],"url":"\/documentation\/niohttp1\/httpserverpipelinehandler","title":"HTTPServerPipelineHandler","abstract":[{"text":"A ","type":"text"},{"code":"ChannelHandler","type":"codeVoice"},{"text":" that handles HTTP pipelining by buffering inbound data until a","type":"text"},{"text":" ","type":"text"},{"text":"response has been sent.","type":"text"}],"type":"topic","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"HTTPServerPipelineHandler"}],"kind":"symbol","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerPipelineHandler"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTPCompression/HTTPResponseCompressor":{"kind":"symbol","abstract":[{"type":"text","text":"A "},{"type":"reference","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/HTTPResponseCompressor","isActive":true},{"type":"text","text":" is a duplex channel handler that handles automatic streaming compression of"},{"type":"text","text":" "},{"type":"text","text":"HTTP responses. It respects the client’s Accept-Encoding preferences, including q-values if present,"},{"type":"text","text":" "},{"type":"text","text":"and ensures that clients are served the compression algorithm that works best for them."}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/HTTPResponseCompressor","type":"topic","title":"HTTPResponseCompressor","url":"\/documentation\/niohttpcompression\/httpresponsecompressor","role":"symbol","navigatorTitle":[{"text":"HTTPResponseCompressor","kind":"identifier"}],"fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"HTTPResponseCompressor","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore":{"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore","kind":"symbol","title":"NIOCore","abstract":[],"url":"\/documentation\/niocore","role":"collection"},"https://en.wikipedia.org/wiki/Pcap":{"identifier":"https:\/\/en.wikipedia.org\/wiki\/Pcap","title":".pcap file","url":"https:\/\/en.wikipedia.org\/wiki\/Pcap","type":"link","titleInlineContent":[{"code":".pcap","type":"codeVoice"},{"text":" file","type":"text"}]},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPServerUpgradeHandler":{"type":"topic","abstract":[{"text":"A server-side channel handler that receives HTTP requests and optionally performs a HTTP-upgrade.","type":"text"},{"text":" ","type":"text"},{"text":"Removes itself from the channel pipeline after the first inbound request on the connection, regardless of","type":"text"},{"text":" ","type":"text"},{"text":"whether the upgrade succeeded or not.","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"HTTPServerUpgradeHandler"}],"title":"HTTPServerUpgradeHandler","fragments":[{"text":"class","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"HTTPServerUpgradeHandler"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerUpgradeHandler","url":"\/documentation\/niohttp1\/httpserverupgradehandler","role":"symbol","kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageHandler":{"type":"topic","abstract":[{"type":"text","text":"A handler which turns a given "},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":" into a "},{"code":"ChannelInboundHandler","type":"codeVoice"},{"type":"text","text":" that can then be added to a"},{"type":"text","text":" "},{"code":"ChannelPipeline","type":"codeVoice"},{"type":"text","text":"."}],"kind":"symbol","url":"\/documentation\/niocore\/bytetomessagehandler","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ByteToMessageHandler","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageHandler","navigatorTitle":[{"text":"ByteToMessageHandler","kind":"identifier"}],"role":"symbol","title":"ByteToMessageHandler","conformance":{"availabilityPrefix":[{"text":"Available when","type":"text"}],"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"code":"Decoder","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":".","type":"text"}]}},"doc://co.pointfree.VaporRouting/documentation/NIOCore/IdleStateHandler":{"navigatorTitle":[{"kind":"identifier","text":"IdleStateHandler"}],"url":"\/documentation\/niocore\/idlestatehandler","title":"IdleStateHandler","abstract":[{"text":"Triggers an IdleStateEvent when a Channel has not performed read, write, or both operation for a while.","type":"text"}],"type":"topic","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"IdleStateHandler"}],"kind":"symbol","role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/IdleStateHandler"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPResponseEncoder":{"title":"HTTPResponseEncoder","url":"\/documentation\/niohttp1\/httpresponseencoder","type":"topic","role":"symbol","abstract":[{"text":"A ","type":"text"},{"type":"codeVoice","code":"ChannelOutboundHandler"},{"text":" that can serialize HTTP responses.","type":"text"}],"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"HTTPResponseEncoder"}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"HTTPResponseEncoder"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPResponseEncoder"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTPCompression/NIOHTTPResponseDecompressor":{"kind":"symbol","abstract":[{"type":"text","text":"Duplex channel handler which will accept deflate and gzip encoded responses and decompress them."}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTPCompression\/NIOHTTPResponseDecompressor","type":"topic","title":"NIOHTTPResponseDecompressor","url":"\/documentation\/niohttpcompression\/niohttpresponsedecompressor","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"NIOHTTPResponseDecompressor"}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOHTTPResponseDecompressor"}]},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPServerProtocolErrorHandler":{"abstract":[{"type":"text","text":"A simple channel handler that catches errors emitted by parsing HTTP requests"},{"type":"text","text":" "},{"type":"text","text":"and sends 400 Bad Request responses."}],"navigatorTitle":[{"text":"HTTPServerProtocolErrorHandler","kind":"identifier"}],"url":"\/documentation\/niohttp1\/httpserverprotocolerrorhandler","role":"symbol","kind":"symbol","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"text":"HTTPServerProtocolErrorHandler","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPServerProtocolErrorHandler","type":"topic","title":"HTTPServerProtocolErrorHandler"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/NIOHTTPResponseHeadersValidator":{"abstract":[{"type":"text","text":"A ChannelHandler to validate that outbound response headers are spec-compliant."}],"navigatorTitle":[{"kind":"identifier","text":"NIOHTTPResponseHeadersValidator"}],"url":"\/documentation\/niohttp1\/niohttpresponseheadersvalidator","role":"symbol","kind":"symbol","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"NIOHTTPResponseHeadersValidator"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/NIOHTTPResponseHeadersValidator","type":"topic","title":"NIOHTTPResponseHeadersValidator"}}}