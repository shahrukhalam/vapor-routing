{"metadata":{"fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ByteToMessageDecoder"}],"externalID":"s:7NIOCore20ByteToMessageDecoderP","modules":[{"name":"NIOCore"}],"roleHeading":"Protocol","symbolKind":"protocol","navigatorTitle":[{"kind":"identifier","text":"ByteToMessageDecoder"}],"title":"ByteToMessageDecoder","role":"symbol"},"schemaVersion":{"major":0,"minor":3,"patch":0},"kind":"symbol","abstract":[{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":"s decode bytes in a stream-like fashion from "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" to another message type."}],"sections":[],"identifier":{"url":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder","interfaceLanguage":"swift"},"hierarchy":{"paths":[["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore"]]},"topicSections":[{"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/InboundOut"],"title":"Associated Types"},{"identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decode(context:buffer:)","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decodeLast(context:buffer:seenEOF:)-1tkzf","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decoderAdded(context:)-7trzq","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decoderRemoved(context:)-sa8l","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/shouldReclaimBytes(buffer:)-5fn2u","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/wrapInboundOut(_:)"],"title":"Instance Methods"}],"primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ByteToMessageDecoder","kind":"identifier"}],"platforms":["Linux"],"languages":["swift"]}]},{"kind":"content","content":[{"level":3,"type":"heading","text":"Purpose","anchor":"Purpose"},{"inlineContent":[{"type":"text","text":"A "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" provides a simplified API for handling streams of incoming data that can be broken"},{"type":"text","text":" "},{"type":"text","text":"up into messages. This API boils down to two methods: "},{"code":"decode","type":"codeVoice"},{"type":"text","text":", and "},{"code":"decodeLast","type":"codeVoice"},{"type":"text","text":". These two methods, when"},{"type":"text","text":" "},{"type":"text","text":"implemented, will be used by a "},{"code":"ByteToMessageHandler","type":"codeVoice"},{"type":"text","text":" paired with a "},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":" to decode the"},{"type":"text","text":" "},{"type":"text","text":"incoming byte stream into a sequence of messages."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The reason this helper exists is to smooth away some of the boilerplate and edge case handling code that"},{"type":"text","text":" "},{"type":"text","text":"is often necessary when implementing parsers in a SwiftNIO "},{"code":"ChannelPipeline","type":"codeVoice"},{"type":"text","text":". A "},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"never needs to worry about how inbound bytes will be buffered, as "},{"code":"ByteToMessageHandler","type":"codeVoice"},{"type":"text","text":" deals with that"},{"type":"text","text":" "},{"type":"text","text":"automatically. A "},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":" also never needs to worry about memory exclusivity violations"},{"type":"text","text":" "},{"type":"text","text":"that can occur when re-entrant "},{"code":"ChannelPipeline","type":"codeVoice"},{"type":"text","text":" operations occur, as "},{"code":"ByteToMessageHandler","type":"codeVoice"},{"type":"text","text":" will deal with"},{"type":"text","text":" "},{"type":"text","text":"those as well."}],"type":"paragraph"},{"level":3,"type":"heading","text":"Implementing ByteToMessageDecoder","anchor":"Implementing-ByteToMessageDecoder"},{"inlineContent":[{"text":"A type that implements ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" may implement two methods: decode and decodeLast. Implementations","type":"text"},{"text":" ","type":"text"},{"text":"must implement decode: if they do not implement decodeLast, a default implementation will be used that","type":"text"},{"text":" ","type":"text"},{"text":"simply calls decode.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"code":"decode","type":"codeVoice"},{"type":"text","text":" is the main decoding method, and is the one that will be called most often. "},{"code":"decode","type":"codeVoice"},{"type":"text","text":" is invoked"},{"type":"text","text":" "},{"type":"text","text":"whenever data is received by the wrapping "},{"code":"ByteToMessageHandler","type":"codeVoice"},{"type":"text","text":". It is invoked with a "},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":" containing"},{"type":"text","text":" "},{"type":"text","text":"all the received data (including any data previously buffered), as well as a "},{"code":"ChannelHandlerContext","type":"codeVoice"},{"type":"text","text":" that can be"},{"type":"text","text":" "},{"type":"text","text":"used in the "},{"code":"decode","type":"codeVoice"},{"type":"text","text":" function."}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"decode"},{"type":"text","text":" is called in a loop by the "},{"type":"codeVoice","code":"ByteToMessageHandler"},{"type":"text","text":". This loop continues until one of two cases occurs:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"The input "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" has no more readable bytes (i.e. "},{"type":"codeVoice","code":".readableBytes == 0"},{"type":"text","text":"); OR"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" method returns "},{"type":"codeVoice","code":".needMoreData"},{"type":"text","text":"."}],"type":"paragraph"}]}],"type":"orderedList"},{"inlineContent":[{"text":"The reason this method is invoked in a loop is to ensure that the stream-like properties of inbound data are","type":"text"},{"text":" ","type":"text"},{"text":"respected. It is entirely possible for ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" to receive either fewer bytes than a single message,","type":"text"},{"text":" ","type":"text"},{"text":"or multiple messages in one go. Rather than have the ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" handle all of the complexity of this,","type":"text"},{"text":" ","type":"text"},{"text":"the logic can be boiled down to a single choice: has the ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" been able to move the state forward","type":"text"},{"text":" ","type":"text"},{"text":"or not? If it has, rather than containing an internal loop it may simply return ","type":"text"},{"type":"codeVoice","code":".continue"},{"text":" in order to request that","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"decode"},{"text":" be invoked again immediately. If it has not, it can return ","type":"text"},{"type":"codeVoice","code":".needMoreData"},{"text":" to ask to be left alone until more","type":"text"},{"text":" ","type":"text"},{"text":"data has been returned from the network.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Essentially, if the next parsing step could not be taken because there wasn’t enough data available, return ","type":"text"},{"code":".needMoreData","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"Otherwise, return ","type":"text"},{"code":".continue","type":"codeVoice"},{"text":". This will allow a ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" implementation to ignore the awkward way data","type":"text"},{"text":" ","type":"text"},{"text":"arrives from the network, and to just treat it as a series of ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":" calls.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"code":"decodeLast","type":"codeVoice"},{"text":" is a cousin of ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":". It is also called in a loop, but unlike with ","type":"text"},{"code":"decode","type":"codeVoice"},{"text":" this loop will only ever","type":"text"},{"text":" ","type":"text"},{"text":"occur once: when the ","type":"text"},{"code":"ChannelHandlerContext","type":"codeVoice"},{"text":" belonging to this ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" is about to become invalidated.","type":"text"},{"text":" ","type":"text"},{"text":"This invalidation happens in two situations: when EOF is received from the network, or when the ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" ","type":"text"},{"text":"is being removed from the ","type":"text"},{"code":"ChannelPipeline","type":"codeVoice"},{"text":". The distinction between these two states is captured by the value of","type":"text"},{"text":" ","type":"text"},{"code":"seenEOF","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"In this condition, the ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" must now produce any final messages it can with the bytes it has","type":"text"},{"text":" ","type":"text"},{"text":"available. In protocols where EOF is used as a message delimiter, having ","type":"text"},{"code":"decodeLast","type":"codeVoice"},{"text":" called with ","type":"text"},{"code":"seenEOF == true","type":"codeVoice"},{"text":" ","type":"text"},{"text":"may produce further messages. In other cases, ","type":"text"},{"code":"decodeLast","type":"codeVoice"},{"text":" may choose to deliver any buffered bytes as “leftovers”,","type":"text"},{"text":" ","type":"text"},{"text":"either in error messages or via ","type":"text"},{"code":"channelRead","type":"codeVoice"},{"text":". This can occur if, for example, a protocol upgrade is occurring.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"As with "},{"type":"codeVoice","code":"decode"},{"type":"text","text":", "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" is invoked in a loop. This allows the same simplification as "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" allows: when"},{"type":"text","text":" "},{"type":"text","text":"a message is completely parsed, the "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" function can return "},{"type":"codeVoice","code":".continue"},{"type":"text","text":" and be re-invoked from the top,"},{"type":"text","text":" "},{"type":"text","text":"rather than containing an internal loop."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Note that the value of "},{"code":"seenEOF","type":"codeVoice"},{"type":"text","text":" may change between calls to "},{"code":"decodeLast","type":"codeVoice"},{"type":"text","text":" in some rare situations."}],"type":"paragraph"},{"level":3,"type":"heading","text":"Implementers Notes","anchor":"Implementers-Notes"},{"inlineContent":[{"text":"\/\/\/ ","type":"text"},{"type":"codeVoice","code":"ByteToMessageHandler"},{"text":" will turn your ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" into a ","type":"text"},{"type":"codeVoice","code":"ChannelInboundHandler"},{"text":". ","type":"text"},{"type":"codeVoice","code":"ByteToMessageHandler"},{"text":" ","type":"text"},{"text":"also solves a couple of tricky issues for you. Most importantly, in a ","type":"text"},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"text":" you do ","type":"text"},{"inlineContent":[{"type":"text","text":"not"}],"type":"emphasis"},{"text":" need to","type":"text"},{"text":" ","type":"text"},{"text":"worry about re-entrancy. Your code owns the passed-in ","type":"text"},{"type":"codeVoice","code":"ByteBuffer"},{"text":" for the duration of the ","type":"text"},{"type":"codeVoice","code":"decode"},{"text":"\/","type":"text"},{"type":"codeVoice","code":"decodeLast"},{"text":" call and","type":"text"},{"text":" ","type":"text"},{"text":"can modify it at will.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If a custom frame decoder is required, then one needs to be careful when implementing"},{"type":"text","text":" "},{"type":"text","text":"one with "},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":". Ensure there are enough bytes in the buffer for a"},{"type":"text","text":" "},{"type":"text","text":"complete frame by checking "},{"code":"buffer.readableBytes","type":"codeVoice"},{"type":"text","text":". If there are not enough bytes"},{"type":"text","text":" "},{"type":"text","text":"for a complete frame, return without modifying the reader index to allow more bytes to arrive."}],"type":"paragraph"},{"inlineContent":[{"text":"To check for complete frames without modifying the reader index, use methods like ","type":"text"},{"code":"buffer.getInteger","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"You  ","type":"text"},{"inlineContent":[{"text":"MUST","type":"text"}],"type":"emphasis"},{"text":" use the reader index when using methods like ","type":"text"},{"code":"buffer.getInteger","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"For example calling ","type":"text"},{"code":"buffer.getInteger(at: 0)","type":"codeVoice"},{"text":" is assuming the frame starts at the beginning of the buffer, which","type":"text"},{"text":" ","type":"text"},{"text":"is not always the case. Use ","type":"text"},{"code":"buffer.getInteger(at: buffer.readerIndex)","type":"codeVoice"},{"text":" instead.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If you move the reader index forward, either manually or by using one of "},{"type":"codeVoice","code":"buffer.read*"},{"type":"text","text":" methods, you must ensure"},{"type":"text","text":" "},{"type":"text","text":"that you no longer need to see those bytes again as they will not be returned to you the next time "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" is"},{"type":"text","text":" "},{"type":"text","text":"called. If you still need those bytes to come back, consider taking a local copy of buffer inside the function to"},{"type":"text","text":" "},{"type":"text","text":"perform your read operations on."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" passed in as "},{"type":"codeVoice","code":"buffer"},{"type":"text","text":" is a slice of a larger buffer owned by the "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" "},{"type":"text","text":"implementation. Some aspects of this buffer are preserved across calls to "},{"type":"codeVoice","code":"decode"},{"type":"text","text":", meaning that any changes to"},{"type":"text","text":" "},{"type":"text","text":"those properties you make in your "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" method will be reflected in the next call to decode. In particular,"},{"type":"text","text":" "},{"type":"text","text":"moving the reader index forward persists across calls. When your method returns, if the reader index has advanced,"},{"type":"text","text":" "},{"type":"text","text":"those bytes are considered “consumed” and will not be available in future calls to "},{"type":"codeVoice","code":"decode"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Please note, however, that the numerical value of the "},{"type":"codeVoice","code":"readerIndex"},{"type":"text","text":" itself is not preserved, and may not be the same"},{"type":"text","text":" "},{"type":"text","text":"from one call to the next. Please do not rely on this numerical value: if you need"},{"type":"text","text":" "},{"type":"text","text":"to recall where a byte is relative to the "},{"type":"codeVoice","code":"readerIndex"},{"type":"text","text":", use an offset rather than an absolute value."}],"type":"paragraph"},{"level":3,"type":"heading","text":"Using ByteToMessageDecoder","anchor":"Using-ByteToMessageDecoder"},{"inlineContent":[{"type":"text","text":"To add a "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" to the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":" use"}],"type":"paragraph"},{"syntax":null,"type":"codeListing","code":["channel.pipeline.addHandler(ByteToMessageHandler(MyByteToMessageDecoder()))"]}]}],"variants":[{"paths":["\/documentation\/niocore\/bytetomessagedecoder"],"traits":[{"interfaceLanguage":"swift"}]}],"relationshipsSections":[{"kind":"relationships","type":"inheritedBy","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOSingleStepByteToMessageDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/WriteObservingByteToMessageDecoder"],"title":"Inherited By"},{"kind":"relationships","type":"conformingTypes","identifiers":["doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/FixedLengthFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LengthFieldBasedFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LineBasedFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOJSONRPCFraming\/ContentLengthHeaderFrameDecoder","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOTLS\/SNIHandler","doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOWebSocket\/WebSocketFrameDecoder"],"title":"Conforming Types"}],"references":{"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/shouldReclaimBytes(buffer:)-5fn2u":{"role":"symbol","url":"\/documentation\/niocore\/bytetomessagedecoder\/shouldreclaimbytes(buffer:)-5fn2u","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/shouldReclaimBytes(buffer:)-5fn2u","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"shouldReclaimBytes","kind":"identifier"},{"text":"(","kind":"text"},{"text":"buffer","kind":"externalParam"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:7NIOCore10ByteBufferV","text":"ByteBuffer","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"preciseIdentifier":"s:Sb","text":"Bool","kind":"typeIdentifier"}],"required":true,"abstract":[{"type":"text","text":"Determine if the read bytes in the given "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" should be reclaimed and their associated memory freed."},{"type":"text","text":" "},{"type":"text","text":"Be aware that reclaiming memory may involve memory copies and so is not free."}],"title":"shouldReclaimBytes(buffer:)","kind":"symbol","defaultImplementations":1},"doc://co.pointfree.VaporRouting/documentation/NIOCore/NIOSingleStepByteToMessageDecoder":{"type":"topic","kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"NIOSingleStepByteToMessageDecoder","kind":"identifier"}],"abstract":[{"type":"text","text":"A simplified version of "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" that can generate zero or one messages for each invocation of "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" or "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Having "},{"type":"codeVoice","code":"decode"},{"type":"text","text":" and "},{"type":"codeVoice","code":"decodeLast"},{"type":"text","text":" return an optional message avoids re-entrancy problems, since the functions relinquish exclusive access"},{"type":"text","text":" "},{"type":"text","text":"to the "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" when returning. This allows for greatly simplified processing."}],"role":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/NIOSingleStepByteToMessageDecoder","url":"\/documentation\/niocore\/niosinglestepbytetomessagedecoder","navigatorTitle":[{"text":"NIOSingleStepByteToMessageDecoder","kind":"identifier"}],"title":"NIOSingleStepByteToMessageDecoder"},"doc://co.pointfree.VaporRouting/documentation/NIOCore":{"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore","kind":"symbol","title":"NIOCore","abstract":[],"url":"\/documentation\/niocore","role":"collection"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/LengthFieldBasedFrameDecoder":{"role":"symbol","kind":"symbol","abstract":[{"type":"text","text":"A decoder that splits the received "},{"code":"ByteBuffer","type":"codeVoice"},{"type":"text","text":" by the number of bytes specified in a fixed length header"},{"text":" ","type":"text"},{"text":"contained within the buffer.","type":"text"}],"title":"LengthFieldBasedFrameDecoder","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"LengthFieldBasedFrameDecoder","kind":"identifier"}],"type":"topic","url":"\/documentation\/nioextras\/lengthfieldbasedframedecoder","navigatorTitle":[{"text":"LengthFieldBasedFrameDecoder","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LengthFieldBasedFrameDecoder"},"doc://co.pointfree.VaporRouting/documentation/NIOWebSocket/WebSocketFrameDecoder":{"fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"WebSocketFrameDecoder","kind":"identifier"}],"type":"topic","abstract":[{"type":"text","text":"An inbound "},{"type":"codeVoice","code":"ChannelHandler"},{"type":"text","text":" that deserializes websocket frames into a structured"},{"type":"text","text":" "},{"type":"text","text":"format for further processing."}],"url":"\/documentation\/niowebsocket\/websocketframedecoder","navigatorTitle":[{"text":"WebSocketFrameDecoder","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOWebSocket\/WebSocketFrameDecoder","kind":"symbol","title":"WebSocketFrameDecoder","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/InboundOut":{"type":"topic","abstract":[{"type":"text","text":"The type of the messages this "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" decodes to."}],"url":"\/documentation\/niocore\/bytetomessagedecoder\/inboundout","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/InboundOut","role":"symbol","fragments":[{"kind":"keyword","text":"associatedtype"},{"kind":"text","text":" "},{"kind":"identifier","text":"InboundOut"}],"kind":"symbol","title":"InboundOut","required":true},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/decode(context:buffer:)":{"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decode(context:buffer:)","role":"symbol","defaultImplementations":1,"url":"\/documentation\/niocore\/bytetomessagedecoder\/decode(context:buffer:)","title":"decode(context:buffer:)","abstract":[{"type":"text","text":"Decode from a "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":"."}],"kind":"symbol","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"decode"},{"kind":"text","text":"("},{"kind":"externalParam","text":"context"},{"text":": ","kind":"text"},{"text":"ChannelHandlerContext","preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"buffer","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"inout","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ByteBuffer","preciseIdentifier":"s:7NIOCore10ByteBufferV","kind":"typeIdentifier"},{"text":") ","kind":"text"},{"text":"throws","kind":"keyword"},{"text":" -> ","kind":"text"},{"text":"DecodingState","preciseIdentifier":"s:7NIOCore13DecodingStateO","kind":"typeIdentifier"}],"required":true},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/NIOJSONRPCFraming/ContentLengthHeaderFrameDecoder":{"url":"\/documentation\/nioextras\/niojsonrpcframing\/contentlengthheaderframedecoder","abstract":[{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOJSONRPCFraming\/ContentLengthHeaderFrameDecoder","isActive":true,"type":"reference"},{"text":" is responsible for parsing JSON-RPC wire protocol with ‘Content-Length’","type":"text"},{"text":" ","type":"text"},{"text":"HTTP-like headers as used by for example by LSP (Language Server Protocol).","type":"text"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ContentLengthHeaderFrameDecoder","kind":"identifier"}],"role":"symbol","title":"NIOJSONRPCFraming.ContentLengthHeaderFrameDecoder","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/NIOJSONRPCFraming\/ContentLengthHeaderFrameDecoder","kind":"symbol","navigatorTitle":[{"text":"ContentLengthHeaderFrameDecoder","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder":{"kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder","title":"ByteToMessageDecoder","navigatorTitle":[{"text":"ByteToMessageDecoder","kind":"identifier"}],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ByteToMessageDecoder","kind":"identifier"}],"abstract":[{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":"s decode bytes in a stream-like fashion from ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":" to another message type.","type":"text"}],"url":"\/documentation\/niocore\/bytetomessagedecoder","type":"topic","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/FixedLengthFrameDecoder":{"fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"FixedLengthFrameDecoder","kind":"identifier"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/FixedLengthFrameDecoder","type":"topic","title":"FixedLengthFrameDecoder","kind":"symbol","url":"\/documentation\/nioextras\/fixedlengthframedecoder","role":"symbol","abstract":[{"type":"text","text":"A decoder that splits the received "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":" by a fixed number"},{"type":"text","text":" "},{"type":"text","text":"of bytes. For example, if you received the following four fragmented packets:"}],"navigatorTitle":[{"text":"FixedLengthFrameDecoder","kind":"identifier"}]},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/wrapInboundOut(_:)":{"url":"\/documentation\/niocore\/bytetomessagedecoder\/wrapinboundout(_:)","abstract":[],"title":"wrapInboundOut(_:)","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/wrapInboundOut(_:)","kind":"symbol","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"wrapInboundOut","kind":"identifier"},{"text":"(","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"text":".","kind":"text"},{"text":"InboundOut","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"preciseIdentifier":"s:7NIOCore6NIOAnyV","text":"NIOAny","kind":"typeIdentifier"}],"role":"symbol","type":"topic"},"doc://co.pointfree.VaporRouting/documentation/NIOHTTP1/HTTPDecoder":{"fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"HTTPDecoder","kind":"identifier"}],"url":"\/documentation\/niohttp1\/httpdecoder","navigatorTitle":[{"text":"HTTPDecoder","kind":"identifier"}],"title":"HTTPDecoder","abstract":[{"text":"A ","type":"text"},{"code":"ChannelInboundHandler","type":"codeVoice"},{"text":" that parses HTTP\/1-style messages, converting them from","type":"text"},{"text":" ","type":"text"},{"text":"unstructured bytes to a sequence of HTTP messages.","type":"text"}],"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOHTTP1\/HTTPDecoder","type":"topic","kind":"symbol","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/WriteObservingByteToMessageDecoder":{"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/WriteObservingByteToMessageDecoder","navigatorTitle":[{"kind":"identifier","text":"WriteObservingByteToMessageDecoder"}],"abstract":[{"type":"text","text":"Some "},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"type":"text","text":"s need to observe "},{"code":"write","type":"codeVoice"},{"text":"s (which are outbound events). ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":"s which","type":"text"},{"text":" ","type":"text"},{"text":"implement the ","type":"text"},{"code":"WriteObservingByteToMessageDecoder","type":"codeVoice"},{"text":" protocol will be notified about every outbound write.","type":"text"}],"url":"\/documentation\/niocore\/writeobservingbytetomessagedecoder","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"WriteObservingByteToMessageDecoder"}],"type":"topic","role":"symbol","title":"WriteObservingByteToMessageDecoder","kind":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOExtras/LineBasedFrameDecoder":{"title":"LineBasedFrameDecoder","kind":"symbol","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"LineBasedFrameDecoder"}],"url":"\/documentation\/nioextras\/linebasedframedecoder","abstract":[{"type":"text","text":"A decoder that splits incoming "},{"type":"codeVoice","code":"ByteBuffer"},{"type":"text","text":"s around line end"},{"type":"text","text":" "},{"type":"text","text":"character(s) ("},{"type":"codeVoice","code":"'\\n'"},{"type":"text","text":" or "},{"type":"codeVoice","code":"'\\r\\n'"},{"type":"text","text":")."}],"role":"symbol","navigatorTitle":[{"kind":"identifier","text":"LineBasedFrameDecoder"}],"type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOExtras\/LineBasedFrameDecoder"},"doc://co.pointfree.VaporRouting/documentation/NIOTLS/SNIHandler":{"fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"SNIHandler","kind":"identifier"}],"url":"\/documentation\/niotls\/snihandler","kind":"symbol","navigatorTitle":[{"text":"SNIHandler","kind":"identifier"}],"abstract":[{"type":"text","text":"A channel handler that can be used to arbitrarily edit a channel"},{"type":"text","text":" "},{"type":"text","text":"pipeline based on the hostname requested in the Server Name Indication"},{"type":"text","text":" "},{"text":"portion of the TLS Client Hello.","type":"text"}],"type":"topic","title":"SNIHandler","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOTLS\/SNIHandler","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/decoderRemoved(context:)-sa8l":{"defaultImplementations":1,"identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decoderRemoved(context:)-sa8l","url":"\/documentation\/niocore\/bytetomessagedecoder\/decoderremoved(context:)-sa8l","kind":"symbol","title":"decoderRemoved(context:)","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"decoderRemoved","kind":"identifier"},{"text":"(","kind":"text"},{"text":"context","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"ChannelHandlerContext","preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC","kind":"typeIdentifier"},{"text":")","kind":"text"}],"required":true,"type":"topic","abstract":[{"type":"text","text":"Called once this "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" is removed from the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":"."}],"role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/decodeLast(context:buffer:seenEOF:)-1tkzf":{"kind":"symbol","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decodeLast(context:buffer:seenEOF:)-1tkzf","title":"decodeLast(context:buffer:seenEOF:)","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"decodeLast"},{"kind":"text","text":"("},{"kind":"externalParam","text":"context"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"ChannelHandlerContext","preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC"},{"kind":"text","text":", "},{"kind":"externalParam","text":"buffer"},{"kind":"text","text":": "},{"kind":"keyword","text":"inout"},{"kind":"text","text":" "},{"kind":"typeIdentifier","text":"ByteBuffer","preciseIdentifier":"s:7NIOCore10ByteBufferV"},{"kind":"text","text":", "},{"kind":"externalParam","text":"seenEOF"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Bool","preciseIdentifier":"s:Sb"},{"kind":"text","text":") "},{"kind":"keyword","text":"throws"},{"kind":"text","text":" -> "},{"kind":"typeIdentifier","text":"DecodingState","preciseIdentifier":"s:7NIOCore13DecodingStateO"}],"required":true,"defaultImplementations":2,"abstract":[{"text":"Decode from a ","type":"text"},{"code":"ByteBuffer","type":"codeVoice"},{"text":" when no more data is incoming and the ","type":"text"},{"code":"ByteToMessageDecoder","type":"codeVoice"},{"text":" is about to leave","type":"text"},{"text":" ","type":"text"},{"text":"the pipeline.","type":"text"}],"url":"\/documentation\/niocore\/bytetomessagedecoder\/decodelast(context:buffer:seeneof:)-1tkzf","type":"topic","role":"symbol"},"doc://co.pointfree.VaporRouting/documentation/NIOCore/ByteToMessageDecoder/decoderAdded(context:)-7trzq":{"role":"symbol","type":"topic","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"decoderAdded","kind":"identifier"},{"text":"(","kind":"text"},{"text":"context","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"ChannelHandlerContext","preciseIdentifier":"s:7NIOCore21ChannelHandlerContextC","kind":"typeIdentifier"},{"kind":"text","text":")"}],"kind":"symbol","defaultImplementations":1,"url":"\/documentation\/niocore\/bytetomessagedecoder\/decoderadded(context:)-7trzq","title":"decoderAdded(context:)","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/NIOCore\/ByteToMessageDecoder\/decoderAdded(context:)-7trzq","abstract":[{"type":"text","text":"Called when this "},{"type":"codeVoice","code":"ByteToMessageDecoder"},{"type":"text","text":" is added to the "},{"type":"codeVoice","code":"ChannelPipeline"},{"type":"text","text":"."}],"required":true}}}