{"schemaVersion":{"minor":3,"patch":0,"major":0},"identifier":{"url":"doc:\/\/co.pointfree.VaporRouting\/documentation\/VaporRouting","interfaceLanguage":"swift"},"hierarchy":{"paths":[[]]},"kind":"symbol","seeAlsoSections":[{"abstract":[{"text":"A free video from ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/www.pointfree.co"},{"text":" demonstrating how to use the vapor-routing library:","type":"text"}],"title":"Related Documentation","identifiers":["http:\/\/pointfree.co\/episodes\/ep188-tour-of-parser-printers-vapor-routing"]}],"metadata":{"roleHeading":"Framework","symbolKind":"module","externalID":"VaporRouting","title":"VaporRouting","role":"collection","modules":[{"name":"VaporRouting"}]},"sections":[],"abstract":[{"text":"A bidirectional Vapor router with more type safety and less fuss.","type":"text"}],"primaryContentSections":[{"content":[{"type":"heading","anchor":"Additional-Resources","level":2,"text":"Additional Resources"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"isActive":true,"identifier":"https:\/\/github.com\/pointfreeco\/vapor-routing","type":"reference"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"isActive":true,"identifier":"https:\/\/github.com\/pointfreeco\/vapor-routing\/discussions","type":"reference"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","identifier":"http:\/\/pointfree.co\/episodes\/ep188-tour-of-parser-printers-vapor-routing","isActive":true}]}]}]},{"type":"heading","anchor":"Motivation","level":2,"text":"Motivation"},{"type":"paragraph","inlineContent":[{"text":"Routing in ","type":"text"},{"isActive":true,"identifier":"http:\/\/vapor.codes","type":"reference"},{"text":" has a simple API that is similar to popular web frameworks in other languages, such as Ruby’s ","type":"text"},{"isActive":true,"identifier":"http:\/\/sinatrarb.com","type":"reference"},{"text":" or Node’s ","type":"text"},{"isActive":true,"identifier":"http:\/\/expressjs.com","type":"reference"},{"text":". It works well for simple routes, but complexity grows over time due to lack of type safety and inability to ","type":"text"},{"inlineContent":[{"text":"generate","type":"text"}],"type":"emphasis"},{"text":" correct URLs to pages on your site.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"To see this, consider an endpoint to fetch a book that is associated with a particular user:","type":"text"}]},{"type":"codeListing","code":["\/\/ GET \/users\/:userId\/books\/:bookId","app.get(\"users\", \":userId\", \"books\", \":bookId\") { req -> Response in","  guard","    let userId = req.parameters.get(\"userId\", Int.self),","    let bookId = req.parameters.get(\"bookId\", Int.self)","  else {","    struct BadRequest: Error {}","    throw BadRequest()","  }","","  \/\/ Logic for fetching user and book and constructing response...","  let user = try await database.fetchUser(user.id)","  let book = try await database.fetchBook(book.id)","  return BookResponse(...)","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When a URL request is made to the server whose method and path matches the above pattern, the closure will be executed for handling that endpoint’s logic."}]},{"type":"paragraph","inlineContent":[{"text":"Notice that we must sprinkle in validation code and error handling into the endpoint’s logic in order to coerce the stringy parameter types into first class data types. This obscures the real logic of the endpoint, and any changes to the route’s pattern must be kept in sync with the validation logic, such as if we wanted to rename “users” to “user” and “books” to “book”.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In addition to these drawbacks, we often need to be able to generate a valid URL to the user’s book page by specifying a user and book id. For example, suppose we wanted to generate an HTML page with a list of all the books for a user, including a link to each book. We have no choice but to manually interpolate a string to form the URL:"}]},{"type":"codeListing","code":["Node.ul(","  user.books.map { book in","    .li(","      .a(.href(\"\/users\/\\(user.id)\/book\/\\(book.id)\"), book.title)","    )","  }",")"],"syntax":"swift"},{"type":"codeListing","code":["<ul>","  <li><a href=\"\/users\/42\/book\/321\">Blob autobiography<\/a><\/li>","  <li><a href=\"\/users\/42\/book\/123\">Life of Blob<\/a><\/li>","  <li><a href=\"\/users\/42\/book\/456\">Blobbed around the world<\/a><\/li>","<\/ul>"],"syntax":"html"},{"type":"paragraph","inlineContent":[{"text":"It is our responsibility to make sure that this interpolated string matches exactly what was specified in the Vapor route. This can be tedious and error prone.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In fact, there is a typo in the above code. The URL constructed goes to “\/book\/:bookId”, but really it should be “\/book"},{"type":"emphasis","inlineContent":[{"type":"text","text":"s"}]},{"type":"text","text":"\/:bookId”:"}]},{"type":"codeListing","code":["- .a(.href(\"\/users\/\\(user.id)\/book\/\\(book.id)\"), book.title)","+ .a(.href(\"\/users\/\\(user.id)\/books\/\\(book.id)\"), book.title)"],"syntax":"diff"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This library aims to solve these problems, and more, when dealing with routing in a Vapor application."}]},{"type":"heading","anchor":"Adding-Parsing-as-a-dependency","level":2,"text":"Adding Parsing as a dependency"},{"type":"paragraph","inlineContent":[{"text":"To use the VaporRouting library in a SwiftPM project, add it to the dependencies of your Package.swift","type":"text"},{"text":" ","type":"text"},{"text":"and specify the ","type":"text"},{"type":"codeVoice","code":"VaporRouting"},{"text":" product in any targets that need access to the library:","type":"text"}]},{"type":"codeListing","code":["let package = Package(","  dependencies: [","    .package(url: \"https:\/\/github.com\/pointfreeco\/vapor-routing\", from: \"0.1.0\"),","  ],","  targets: [","    .target(","      name: \"<target-name>\",","      dependencies: [.product(name: \"VaporRouting\", package: \"vapor-routing\")]","    )","  ]",")"],"syntax":"swift"},{"type":"heading","anchor":"Getting-started","level":2,"text":"Getting started"},{"type":"paragraph","inlineContent":[{"text":"To use this libary, one starts by constructing an enum that describes all the routes your website supports. For example, the book endpoint described above can be represented as:","type":"text"}]},{"type":"codeListing","code":["enum SiteRoute {","  case userBook(userId: Int, bookId: Int)","  \/\/ more cases for each route","}"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"Then you construct a router as a parser-printer from our "},{"type":"reference","identifier":"http:\/\/github.com\/pointfreeco\/swift-parsing","isActive":true},{"type":"text","text":", which is an object that is capable of parsing URL requests in "},{"type":"codeVoice","code":"SiteRoute"},{"type":"text","text":" and "},{"type":"emphasis","inlineContent":[{"text":"printing","type":"text"}]},{"type":"text","text":" "},{"type":"codeVoice","code":"SiteRoute"},{"type":"text","text":" values back into URL requests. Such routers can be constructed with various parser-printers the library vends, such as "},{"type":"codeVoice","code":"Path"},{"type":"text","text":", "},{"type":"codeVoice","code":"Query"},{"type":"text","text":", "},{"type":"codeVoice","code":"Body"},{"type":"text","text":" and more:"}],"type":"paragraph"},{"code":["import VaporRouting","","let siteRouter = OneOf {","  \/\/ Maps the URL \"\/users\/:userId\/books\/:bookId\" to the","  \/\/ SiteRouter.userBook enum case.","  Route(.case(SiteRouter.userBook)) {","    Path { \"users\"; Digits(); \"books\"; Digits() }","  }","","  \/\/ More uses of Route for each case in SiteRoute","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Once that little bit of upfront work is done, using the router doesn’t look too dissimilar from using Vapor’s native routing tools. First you mount the router to the application to take care of all routing responsibilities, and you do so by providing a closure that transforms ","type":"text"},{"type":"codeVoice","code":"SiteRoute"},{"text":" to a response:","type":"text"}],"type":"paragraph"},{"code":["\/\/ configure.swift","public func configure(_ app: Application) throws {","  ...","","  app.mount(siteRouter, use: siteHandler)","}","","func siteHandler(","  request: Request,","  route: SiteRoute",") async throws -> AsyncResponseEncodable {","  switch route {","  case .userBook(userId: userId, bookId: bookId):","    let user = try await database.fetchUser(user.id)","    let book = try await database.fetchBook(book.id)","    return BookResponse(...)","","  \/\/ more cases...","  }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Notice that handling the ","type":"text"},{"code":".userBook","type":"codeVoice"},{"text":" case is entirely focused on just the logic for the endpoint, not parsing and validating the parameters in the URL.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"With that done you can now easily generate URLs to any part of your website usinge a type safe, concise API. For example, generating the list of book links now looks like this:"}],"type":"paragraph"},{"code":["Node.ul(","  user.books.map { book in","    .li(","      .a(","        .href(siteRouter.path(for: .userBook(userId: user.id, bookId: book.id)),","        book.title","      )","    )","  }",")"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Note there is no string interpolation or guessing what shape the path should be in. All of that is handled by the router. We only have to provide the data for the user and book ids, and the router takes care of the rest. If we make a change to the "},{"type":"codeVoice","code":"siteRouter"},{"type":"text","text":", such as recognizer the singular form “\/user\/:userId\/book\/:bookId”, then all paths will automatically be updated. We will not need to search the code base to replace “users” with “user” and “books” with “book”."}],"type":"paragraph"},{"text":"Global router","anchor":"Global-router","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"It is best practice to put a router in your global application context rather than reach"},{"type":"text","text":" "},{"type":"text","text":"out to a globally defined router. To do this you can define a "},{"type":"codeVoice","code":"StorageKey"},{"type":"text","text":" conformance"},{"type":"text","text":" "},{"type":"text","text":"to represent the router’s type and add a computed property on Vapor’s "},{"type":"codeVoice","code":"Application"},{"type":"text","text":" type:"}],"type":"paragraph"},{"code":["enum SiteRouterKey: StorageKey {","  typealias Value = AnyParserPrinter<URLRequestData, SiteRoute>","}","","extension Application {","  var router: SiteRouterKey.Value {","    get {","      self.storage[SiteRouterKey.self]!","    }","    set {","      self.storage[SiteRouterKey.self] = newValue","    }","  }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Then you can set the router on the application instance handed to your ","type":"text"},{"code":"configure","type":"codeVoice"},{"text":" function:","type":"text"}],"type":"paragraph"},{"code":["\/\/ configure.swift","public func configure(_ app: Application) throws {","  ...","","  app.router = router","    .eraseToAnyParserPrinter()","  app.mount(app.router, use: siteHandler)","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This is also an appropriate place to configure the base URL of the router so that when you","type":"text"},{"text":" ","type":"text"},{"text":"need to generate absolute URLs (e.g. for emails) you can do so correctly:","type":"text"}],"type":"paragraph"},{"code":["\/\/ configure.swift","public func configure(_ app: Application) throws {","  ...","","  app.router = router","    .baseUrl(","      app.environment == .production ? \"http:\/\/www.mysite.com\"","      : app.environment == .staging ? \"http:\/\/staging.mysite.com\"","      : \"http:\/\/localhost:8080\"","    )","    .eraseToAnyParserPrinter()","","  app.mount(app.router, use: siteHandler)","}"],"type":"codeListing","syntax":"swift"}],"kind":"content"}],"variants":[{"paths":["\/documentation\/vaporrouting"],"traits":[{"interfaceLanguage":"swift"}]}],"references":{"https://github.com/pointfreeco/vapor-routing":{"url":"https:\/\/github.com\/pointfreeco\/vapor-routing","type":"link","identifier":"https:\/\/github.com\/pointfreeco\/vapor-routing","titleInlineContent":[{"type":"text","text":"GitHub Repo"}],"title":"GitHub Repo"},"http://sinatrarb.com":{"url":"http:\/\/sinatrarb.com","type":"link","identifier":"http:\/\/sinatrarb.com","titleInlineContent":[{"type":"text","text":"Sinatra"}],"title":"Sinatra"},"http://expressjs.com":{"url":"http:\/\/expressjs.com","type":"link","identifier":"http:\/\/expressjs.com","titleInlineContent":[{"type":"text","text":"Express"}],"title":"Express"},"http://github.com/pointfreeco/swift-parsing":{"url":"http:\/\/github.com\/pointfreeco\/swift-parsing","type":"link","identifier":"http:\/\/github.com\/pointfreeco\/swift-parsing","titleInlineContent":[{"type":"text","text":"parsing library"}],"title":"parsing library"},"http://pointfree.co/episodes/ep188-tour-of-parser-printers-vapor-routing":{"url":"http:\/\/pointfree.co\/episodes\/ep188-tour-of-parser-printers-vapor-routing","type":"link","identifier":"http:\/\/pointfree.co\/episodes\/ep188-tour-of-parser-printers-vapor-routing","titleInlineContent":[{"type":"text","text":"Point-Free Video"}],"title":"Point-Free Video"},"doc://co.pointfree.VaporRouting/documentation/VaporRouting":{"url":"\/documentation\/vaporrouting","kind":"symbol","role":"collection","type":"topic","identifier":"doc:\/\/co.pointfree.VaporRouting\/documentation\/VaporRouting","abstract":[{"type":"text","text":"A bidirectional Vapor router with more type safety and less fuss."}],"title":"VaporRouting"},"https://github.com/pointfreeco/vapor-routing/discussions":{"url":"https:\/\/github.com\/pointfreeco\/vapor-routing\/discussions","type":"link","identifier":"https:\/\/github.com\/pointfreeco\/vapor-routing\/discussions","titleInlineContent":[{"type":"text","text":"Discussions"}],"title":"Discussions"},"http://vapor.codes":{"url":"http:\/\/vapor.codes","type":"link","identifier":"http:\/\/vapor.codes","titleInlineContent":[{"type":"text","text":"Vapor"}],"title":"Vapor"}}}